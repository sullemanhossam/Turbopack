import { Text } from "@codemirror/next/text";
import { ChangeSet } from "@codemirror/next/state";
import { DecorationSet, BlockType } from "./decoration";
import { ChangedRange } from "./extension";
import { Direction } from "./bidi";
export declare class HeightOracle {
    doc: Text;
    lineWrapping: boolean;
    direction: Direction;
    heightSamples: {
        [key: number]: boolean;
    };
    lineHeight: number;
    charWidth: number;
    lineLength: number;
    heightChanged: boolean;
    heightForGap(from: number, to: number): number;
    heightForLine(length: number): number;
    setDoc(doc: Text): this;
    mustRefresh(lineHeights: number[], whiteSpace: string, direction: Direction): boolean;
    refresh(whiteSpace: string, direction: Direction, lineHeight: number, charWidth: number, lineLength: number, knownHeights: number[]): boolean;
}
export declare class MeasuredHeights {
    readonly from: number;
    readonly heights: number[];
    index: number;
    constructor(from: number, heights: number[]);
    get more(): boolean;
}
export declare class BlockInfo {
    readonly from: number;
    readonly length: number;
    readonly top: number;
    readonly height: number;
    readonly type: BlockType | readonly BlockInfo[];
    get to(): number;
    get bottom(): number;
}
export declare enum QueryType {
    ByPos = 0,
    ByHeight = 1,
    ByPosNoHeight = 2
}
export declare abstract class HeightMap {
    length: number;
    height: number;
    flags: number;
    constructor(length: number, // The number of characters covered
    height: number, // Height of this part of the document
    flags?: number);
    size: number;
    get outdated(): boolean;
    set outdated(value: boolean);
    abstract blockAt(height: number, doc: Text, top: number, offset: number): BlockInfo;
    abstract lineAt(value: number, type: QueryType, doc: Text, top: number, offset: number): BlockInfo;
    abstract forEachLine(from: number, to: number, doc: Text, top: number, offset: number, f: (line: BlockInfo) => void): void;
    abstract updateHeight(oracle: HeightOracle, offset?: number, force?: boolean, measured?: MeasuredHeights): HeightMap;
    abstract toString(): void;
    setHeight(oracle: HeightOracle, height: number): void;
    replace(_from: number, _to: number, nodes: (HeightMap | null)[]): HeightMap;
    decomposeLeft(_to: number, result: (HeightMap | null)[]): void;
    decomposeRight(_from: number, result: (HeightMap | null)[]): void;
    applyChanges(decorations: readonly DecorationSet[], oldDoc: Text, oracle: HeightOracle, changes: readonly ChangedRange[]): HeightMap;
    static empty(): HeightMap;
    static of(nodes: (HeightMap | null)[]): HeightMap;
}
export declare function heightRelevantDecoChanges(a: readonly DecorationSet[], b: readonly DecorationSet[], diff: ChangeSet): number[];
//# sourceMappingURL=heightmap.d.ts.map