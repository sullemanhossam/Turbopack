import { EditorState, ChangeSet, ChangeDesc, SelectionRange } from "@codemirror/next/state";
import { Rect } from "./dom";
import { HeightMap, HeightOracle, BlockInfo } from "./heightmap";
import { ViewUpdate, UpdateFlag } from "./extension";
import { Decoration, DecorationSet } from "./decoration";
import { DocView } from "./docview";
export declare class LineGap {
    readonly from: number;
    readonly to: number;
    readonly size: number;
    constructor(from: number, to: number, size: number);
    static same(a: readonly LineGap[], b: readonly LineGap[]): boolean;
    draw(wrapping: boolean): import("../../rangeset/src/rangeset").Range<Decoration>;
}
export declare class ViewState {
    state: EditorState;
    pixelViewport: Rect;
    paddingTop: number;
    paddingBottom: number;
    heightOracle: HeightOracle;
    heightMap: HeightMap;
    scrollTo: SelectionRange | null;
    printing: boolean;
    viewport: Viewport;
    visibleRanges: readonly {
        from: number;
        to: number;
    }[];
    lineGaps: readonly LineGap[];
    lineGapDeco: DecorationSet;
    mustEnforceCursorAssoc: boolean;
    constructor(state: EditorState);
    update(update: ViewUpdate, scrollTo?: SelectionRange | null): void;
    measure(docView: DocView, repeated: boolean): number;
    getViewport(bias: number, scrollTo: SelectionRange | null): Viewport;
    mapViewport(viewport: Viewport, changes: ChangeDesc): Viewport;
    viewportIsAppropriate({ from, to }: Viewport, bias?: number): boolean;
    mapLineGaps(gaps: readonly LineGap[], changes: ChangeSet): readonly LineGap[];
    ensureLineGaps(current: readonly LineGap[]): LineGap[];
    gapSize(line: BlockInfo, pos: number, start: boolean, structure: {
        total: number;
        ranges: {
            from: number;
            to: number;
        }[];
    }): number;
    updateLineGaps(gaps: readonly LineGap[]): 0 | UpdateFlag.LineGaps;
    computeVisibleRanges(): void;
    lineAt(pos: number, editorTop: number): BlockInfo;
    lineAtHeight(height: number, editorTop: number): BlockInfo;
    blockAtHeight(height: number, editorTop: number): BlockInfo;
    forEachLine(from: number, to: number, f: (line: BlockInfo) => void, editorTop: number): void;
}
export declare class Viewport {
    readonly from: number;
    readonly to: number;
    constructor(from: number, to: number);
    eq(b: Viewport): boolean;
}
//# sourceMappingURL=viewstate.d.ts.map