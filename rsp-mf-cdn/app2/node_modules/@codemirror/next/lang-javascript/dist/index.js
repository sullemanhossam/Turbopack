import { parser } from 'lezer-javascript';
import { continuedIndent, LezerSyntax, indentNodeProp, flatIndent, foldNodeProp } from '@codemirror/next/syntax';
import { styleTags } from '@codemirror/next/highlight';
import { completeSnippets } from '@codemirror/next/autocomplete';
import { EditorState } from '@codemirror/next/state';

/// A collection of JavaScript-related
/// [snippets](#autocomplete.snippet).
const snippets = [
    { keyword: "function",
        name: "function definition",
        snippet: "function ${name}(${params}) {\n\t${}\n}" },
    { keyword: "for",
        name: "for loop",
        snippet: "for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}" },
    { keyword: "for",
        name: "for of loop",
        snippet: "for (let ${name} of ${collection}) {\n\t${}\n}" },
    { keyword: "try",
        name: "try block",
        snippet: "try {\n\t${}\n} catch (${error}) {\n\t${}\n}" },
    { keyword: "class",
        name: "class definition",
        snippet: "class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}" },
    { keyword: "import",
        name: "import named",
        snippet: "import {${names}} from \"${module}\"\n${}" },
    { keyword: "import",
        name: "import default",
        snippet: "import ${name} from \"${module}\"\n${}" }
];

const statementIndent = continuedIndent({ except: /^{/ });
/// A syntax provider based on the [Lezer JavaScript
/// parser](https://github.com/lezer-parser/javascript), extended with
/// highlighting and indentation information.
const javascriptSyntax = new LezerSyntax(parser.withProps(indentNodeProp.add(type => {
    if (type.name == "IfStatement")
        return continuedIndent({ except: /^\s*({|else\b)/ });
    if (type.name == "TryStatement")
        return continuedIndent({ except: /^\s*({|catch|finally)\b/ });
    if (type.name == "LabeledStatement")
        return flatIndent;
    if (type.name == "SwitchBody")
        return context => {
            let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
            return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        };
    if (type.name == "TemplateString" || type.name == "BlockComment")
        return () => -1;
    if (/(Statement|Declaration)$/.test(type.name) || type.name == "Property")
        return statementIndent;
    return undefined;
}), foldNodeProp.add({
    Block(tree) { return { from: tree.start + 1, to: tree.end - 1 }; },
    ObjectExpression(tree) { return { from: tree.start + 1, to: tree.end - 1 }; },
    ArrayExpression(tree) { return { from: tree.start + 1, to: tree.end - 1 }; },
    BlockComment(tree) { return { from: tree.start + 2, to: tree.end - 2 }; }
}), styleTags({
    "get set async static": "modifier",
    "for while do if else switch try catch finally return throw break continue default case": "keyword control",
    "in of await yield void typeof delete instanceof": "operatorKeyword",
    "export import let var const function class extends": "keyword definition",
    "with debugger from as": "keyword",
    TemplateString: "string#2",
    "BooleanLiteral Super": "atom",
    this: "self",
    null: "null",
    Star: "modifier",
    VariableName: "variableName",
    VariableDefinition: "variableName definition",
    Label: "labelName",
    PropertyName: "propertyName",
    PropertyNameDefinition: "propertyName definition",
    "PostfixOp UpdateOp": "updateOperator",
    LineComment: "lineComment",
    BlockComment: "blockComment",
    Number: "number",
    String: "string",
    ArithOp: "arithmeticOperator",
    LogicOp: "logicOperator",
    BitOp: "bitwiseOperator",
    CompareOp: "compareOperator",
    RegExp: "regexp",
    Equals: "operator definition",
    Spread: "punctuation",
    "Arrow :": "punctuation definition",
    "( )": "paren",
    "[ ]": "squareBracket",
    "{ }": "brace",
    ".": "derefOperator",
    ", ;": "separator"
})), {
    languageData: {
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
        commentTokens: { line: "//", block: { open: "/*", close: "*/" } }
    }
});
/// Returns an extension that installs JavaScript support features
/// (completion of [snippets](#javascript.snippets)).
function javascriptSupport() {
    return javascriptSyntax.languageData.of({ autocomplete: completeSnippets(snippets) });
}
/// Returns an extension that installs the JavaScript syntax and
/// support features.
function javascript() {
    return [javascriptSyntax, javascriptSupport()];
}

/// Connects an [ESLint](https://eslint.org/) linter to CodeMirror's
/// [lint](#lint) integration. `eslint` should be an instance of the
/// [`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)
/// class, and `config` an optional ESLint configuration. The return
/// value of this function can be passed to [`linter`](#lint.linter)
/// to create a JavaScript linting extension.
///
/// Note that ESLint targets node, and is tricky to run in the
/// browser. The [eslint4b](https://github.com/mysticatea/eslint4b)
/// and
/// [eslint4b-prebuilt](https://github.com/marijnh/eslint4b-prebuilt/)
/// packages may help with that.
function esLint(eslint, config) {
    if (!config) {
        config = {
            parserOptions: { ecmaVersion: 2019, sourceType: "module" },
            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
            rules: {}
        };
        eslint.getRules().forEach((desc, name) => {
            if (desc.meta.docs.recommended)
                config.rules[name] = 2;
        });
    }
    function range(state, from = 0, to = state.doc.length) {
        let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };
        return eslint.verify(state.sliceDoc(from, to), config)
            .map((val) => translateDiagnostic(val, state.doc, offset));
    }
    return (view) => {
        let [syntax] = view.state.facet(EditorState.syntax);
        if (syntax == javascriptSyntax)
            return range(view.state);
        if (!syntax || !(syntax instanceof LezerSyntax && syntax.parser.hasNested))
            return [];
        let found = [];
        // FIXME move to async parsing?
        syntax.getTree(view.state).iterate({
            enter(type, start, end) {
                if (type == javascriptSyntax.parser.topType) {
                    for (let d of range(view.state, start, end))
                        found.push(d);
                    return false;
                }
                return undefined;
            }
        });
        return found;
    };
}
function mapPos(line, col, doc, offset) {
    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);
}
function translateDiagnostic(input, doc, offset) {
    let start = mapPos(input.line, input.column, doc, offset);
    let result = {
        from: start,
        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,
        message: input.message,
        source: input.ruleId ? "jshint:" + input.ruleId : "jshint",
        severity: input.severity == 1 ? "warning" : "error",
    };
    if (input.fix) {
        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;
        result.actions = [{
                name: "fix",
                apply(view, start) {
                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });
                }
            }];
    }
    return result;
}

export { esLint, javascript, javascriptSupport, javascriptSyntax, snippets };
