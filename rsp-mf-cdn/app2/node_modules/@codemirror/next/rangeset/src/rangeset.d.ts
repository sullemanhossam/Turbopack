import { ChangeDesc, MapMode } from "@codemirror/next/state";
export declare abstract class RangeValue {
    eq(other: RangeValue): boolean;
    startSide: number;
    endSide: number;
    mapMode: MapMode;
    point: boolean;
    range(from: number, to?: number): Range<this>;
}
export declare class Range<T extends RangeValue> {
    readonly from: number;
    readonly to: number;
    readonly value: T;
}
export interface RangeComparator<T extends RangeValue> {
    compareRange(from: number, to: number, activeA: T[], activeB: T[]): void;
    comparePoint(from: number, to: number, byA: T | null, byB: T | null): void;
    minPointSize?: number;
}
export interface SpanIterator<T extends RangeValue> {
    span(from: number, to: number, active: readonly T[]): void;
    point(from: number, to: number, value: T, openStart: boolean, openEnd: boolean): void;
    minPointSize?: number;
}
export declare type RangeCursor<T> = {
    next: () => void;
    value: T | null;
    from: number;
    to: number;
};
declare type RangeSetUpdate<T extends RangeValue> = {
    add?: readonly Range<T>[];
    sort?: boolean;
    filter?: (from: number, to: number, value: T) => boolean;
    filterFrom?: number;
    filterTo?: number;
};
export declare class RangeSet<T extends RangeValue> {
    update(updateSpec: RangeSetUpdate<T>): RangeSet<T>;
    map(changes: ChangeDesc): RangeSet<T>;
    between(from: number, to: number, f: (from: number, to: number, value: T) => void | false): void;
    iter(from?: number): RangeCursor<T>;
    static iter<T extends RangeValue>(sets: readonly RangeSet<T>[], from?: number): RangeCursor<T>;
    static compare<T extends RangeValue>(oldSets: readonly RangeSet<T>[], newSets: readonly RangeSet<T>[], textDiff: ChangeDesc, comparator: RangeComparator<T>): void;
    static spans<T extends RangeValue>(sets: readonly RangeSet<T>[], from: number, to: number, iterator: SpanIterator<T>): void;
    static of<T extends RangeValue>(ranges: readonly Range<T>[] | Range<T>, sort?: boolean): RangeSet<T>;
    static empty: RangeSet<any>;
}
export declare class RangeSetBuilder<T extends RangeValue> {
    private chunks;
    private chunkPos;
    private chunkStart;
    private last;
    private lastFrom;
    private lastTo;
    private from;
    private to;
    private value;
    private maxPoint;
    private setMaxPoint;
    private nextLayer;
    private finishChunk;
    constructor();
    add(from: number, to: number, value: T): void;
    finish(): RangeSet<T>;
}
export {};
//# sourceMappingURL=rangeset.d.ts.map