import { ViewPlugin, themeClass, Direction, EditorView } from '@codemirror/next/view';
import { Facet, StateEffect, StateField, MapMode } from '@codemirror/next/state';

const tooltipPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        view.scrollDOM.addEventListener("scroll", this.onscroll = this.onscroll.bind(this));
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.tooltips = view.state.facet(showTooltip);
        this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));
    }
    update(update) {
        let tooltips = update.state.facet(showTooltip);
        if (tooltips == this.tooltips) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
        }
        else {
            let views = [];
            for (let i = 0; i < tooltips.length; i++) {
                let tip = tooltips[i], known = -1;
                for (let i = 0; i < this.tooltips.length; i++)
                    if (this.tooltips[i].create == tip.create)
                        known = i;
                if (known < 0) {
                    views[i] = this.createTooltip(tip);
                }
                else {
                    let tooltipView = views[i] = this.tooltipViews[known];
                    if (tooltipView.update)
                        tooltipView.update(update);
                }
            }
            for (let t of this.tooltipViews)
                if (views.indexOf(t) < 0)
                    t.dom.remove();
            this.tooltips = tooltips;
            this.tooltipViews = views;
            if (this.tooltips.length)
                this.view.requestMeasure(this.measureReq);
        }
        if (update.docChanged && this.tooltips.length)
            this.view.requestMeasure(this.measureReq);
    }
    createTooltip(tooltip) {
        let tooltipView = tooltip.create(this.view);
        tooltipView.dom.className = themeClass("tooltip" + (tooltip.style ? "." + tooltip.style : ""));
        this.view.dom.appendChild(tooltipView.dom);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        return tooltipView;
    }
    destroy() {
        this.view.scrollDOM.removeEventListener("scroll", this.onscroll);
        for (let { dom } of this.tooltipViews)
            dom.remove();
    }
    readMeasure() {
        return {
            editor: this.view.dom.getBoundingClientRect(),
            pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),
            size: this.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight
        };
    }
    writeMeasure(measured) {
        let { editor } = measured;
        for (let i = 0; i < this.tooltipViews.length; i++) {
            let tooltip = this.tooltips[i], { dom } = this.tooltipViews[i], pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {
                dom.style.top = "-10000px";
                continue;
            }
            let width = size.right - size.left, height = size.bottom - size.top;
            let left = this.view.textDirection == Direction.LTR ? Math.min(pos.left, measured.innerWidth - width)
                : Math.max(0, pos.left - width);
            let above = !!tooltip.above;
            if (!tooltip.strictSide &&
                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))
                above = !above;
            dom.style.top = ((above ? pos.top - height : pos.bottom) - editor.top) + "px";
            dom.style.left = (left - editor.left) + "px";
        }
    }
    onscroll() {
        if (this.tooltips.length)
            this.view.requestMeasure(this.measureReq);
    }
});
const baseTheme = EditorView.baseTheme({
    tooltip: {
        position: "absolute",
        border: "1px solid silver",
        backgroundColor: "#f5f5f5",
        zIndex: 100
    }
});
/// Supporting extension for displaying tooltips. Allows
/// [`showTooltip`](#tooltip.showTooltip) to be used to define
/// tooltips.
function tooltips() {
    return [tooltipPlugin, baseTheme];
}
/// Behavior by which an extension can provide a tooltip to be shown.
const showTooltip = Facet.define();
const HoverTime = 750, HoverMaxDist = 10;
class HoverPlugin {
    constructor(view, source, field, setHover) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.lastMouseMove = null;
        this.hoverTimeout = -1;
        this.mouseInside = false;
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseenter", this.mouseenter = this.mouseenter.bind(this));
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (!this.mouseInside || this.active)
            return;
        let now = Date.now(), lastMove = this.lastMouseMove;
        if (now - lastMove.timeStamp < HoverTime) {
            this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));
            return;
        }
        let pos = this.view.contentDOM.contains(lastMove.target)
            ? this.view.posAtCoords({ x: lastMove.clientX, y: lastMove.clientY }) : -1;
        let open = pos < 0 ? null : this.source(this.view, (from, to) => {
            return from <= pos && to >= pos && (from == to || isOverRange(this.view, from, to, lastMove.clientX, lastMove.clientY));
        });
        if (open)
            this.view.dispatch({ effects: this.setHover.of(open) });
    }
    mousemove(event) {
        var _a;
        this.lastMouseMove = event;
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, HoverTime);
        let tooltip = this.active;
        if (tooltip && !isInTooltip(event.target)) {
            let { pos } = tooltip, end = (_a = tooltip.end) !== null && _a !== void 0 ? _a : pos;
            if ((pos == end ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist)))
                this.view.dispatch({ effects: this.setHover.of(null) });
        }
    }
    mouseenter() {
        this.mouseInside = true;
    }
    mouseleave() {
        this.mouseInside = false;
        if (this.active)
            this.view.dispatch({ effects: this.setHover.of(null) });
    }
    destroy() {
        this.view.dom.removeEventListener("mouseenter", this.mouseenter.bind(this));
        this.view.dom.removeEventListener("mouseleave", this.mouseleave.bind(this));
        this.view.dom.removeEventListener("mousemove", this.mousemove.bind(this));
    }
}
function isInTooltip(elt) {
    for (let cur = elt; cur; cur = cur.parentNode)
        if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
            return true;
    return false;
}
function isOverRange(view, from, to, x, y, margin = 0) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
        if (dist <= margin)
            return true;
    }
    return false;
}
/// Enable a hover tooltip, which shows up when the pointer hovers
/// over ranges of text. The callback should, for each hoverable
/// range, call its `check` argument to see if that range is being
/// hovered over, and return a tooltip description when it is.
function hoverTooltip(source, options = {}) {
    const setHover = StateEffect.define();
    const hoverState = StateField.define({
        create() { return null; },
        update(value, tr) {
            if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))
                return null;
            for (let effect of tr.effects)
                if (effect.is(setHover))
                    return effect.value;
            if (value && tr.docChanged) {
                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
                if (newPos < 0)
                    return null;
                let copy = Object.assign(Object.create(null), value);
                copy.pos = newPos;
                if (value.end != null)
                    copy.end = tr.changes.mapPos(value.end);
                return copy;
            }
            return value;
        },
        provide: [showTooltip.nFrom(v => v ? [v] : [])]
    });
    return [
        hoverState,
        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover)),
        tooltips()
    ];
}

export { hoverTooltip, showTooltip, tooltips };
