import { EditorSelection } from '@codemirror/next/state';

/// Comments or uncomments the current `SelectionRange` using line-comments.
/// The line-comment token is defined on a language basis.
const toggleLineComment = target => {
    return dispatch(toggleLineCommentWithOption(CommentOption.Toggle), target);
};
/// Comments the current `SelectionRange` using line-comments.
/// The line-comment token is defined on a language basis.
const lineComment = target => {
    return dispatch(toggleLineCommentWithOption(CommentOption.OnlyComment), target);
};
/// Uncomments the current `SelectionRange` using line-comments.
/// The line-comment token is defined on a language basis.
const lineUncomment = target => {
    return dispatch(toggleLineCommentWithOption(CommentOption.OnlyUncomment), target);
};
/// Comments or uncomments the current `SelectionRange` using block-comments.
/// The block-comment tokens are defined on a language basis.
const toggleBlockComment = target => {
    return dispatch(toggleBlockCommentWithOption(CommentOption.Toggle), target);
};
/// Comments the current `SelectionRange` using block-comments.
/// The block-comment tokens are defined on a language basis.
const blockComment = target => {
    return dispatch(toggleBlockCommentWithOption(CommentOption.OnlyComment), target);
};
/// Uncomments the current `SelectionRange` using block-comments.
/// The block-comment tokens are defined on a language basis.
const blockUncomment = target => {
    return dispatch(toggleBlockCommentWithOption(CommentOption.OnlyUncomment), target);
};
/// Default key bindings for this package.
///
///  - Ctrl-/ (Cmd-/ on macOS): [\`toggleLineComment\`](#comment.toggleLineComment).
///  - Shift-Alt-a: [\`toggleBlockComment\`](#comment.toggleBlockComment).
const commentKeymap = [
    { key: "Mod-/", run: toggleLineComment },
    { key: "Alt-A", run: toggleBlockComment }
];
function dispatch(cmd, target) {
    const tr = cmd(target.state);
    if (!tr)
        return false;
    target.dispatch(tr);
    return true;
}
var CommentOption;
(function (CommentOption) {
    CommentOption[CommentOption["Toggle"] = 0] = "Toggle";
    CommentOption[CommentOption["OnlyComment"] = 1] = "OnlyComment";
    CommentOption[CommentOption["OnlyUncomment"] = 2] = "OnlyUncomment";
})(CommentOption || (CommentOption = {}));
function getConfig(state, pos = state.selection.primary.head) {
    return state.languageDataAt("commentTokens", pos)[0] || {};
}
const toggleBlockCommentWithOption = (option) => (state) => {
    const config = getConfig(state);
    return config.block ? new BlockCommenter(config.block.open, config.block.close).toggle(option, state) : null;
};
const toggleLineCommentWithOption = (option) => (state) => {
    const config = getConfig(state);
    return config.line ? new LineCommenter(config.line).toggle(option, state) : null;
};
// This class performs toggle, comment and uncomment
// of block comments in languages that support them.
// The `open` and `close` arguments refer to the open and close
// tokens of which this `BlockCommenter` is made up.
class BlockCommenter {
    constructor(open, close, margin = " ") {
        this.open = open;
        this.close = close;
        this.margin = margin;
    }
    toggle(option, state) {
        const selectionCommented = this.isSelectionCommented(state);
        if (selectionCommented !== null) {
            if (option !== CommentOption.OnlyComment) {
                return state.update({
                    changes: selectionCommented.map(({ open, close }) => [
                        { from: open.pos - this.open.length, to: open.pos + open.margin },
                        { from: close.pos - close.margin, to: close.pos + this.close.length }
                    ])
                });
            }
        }
        else {
            if (option !== CommentOption.OnlyUncomment) {
                return state.update(state.changeByRange(range => {
                    const shift = (this.open + this.margin).length;
                    return {
                        changes: [{ from: range.from, insert: this.open + this.margin },
                            { from: range.to, insert: this.margin + this.close }],
                        range: EditorSelection.range(range.anchor + shift, range.head + shift)
                    };
                }));
            }
        }
        return null;
    }
    /// Determines whether all selection ranges in `state` are block-commented.
    isSelectionCommented(state) {
        let result = [];
        for (const range of state.selection.ranges) {
            const x = this.isRangeCommented(state, range);
            if (x === null)
                return null;
            result.push(x);
        }
        return result;
    }
    /// Determines if the `range` is block-commented in the given `state`.
    /// The `range` must be a valid range in `state`.
    isRangeCommented(state, range) {
        let textBefore = state.sliceDoc(range.from - SearchMargin, range.from);
        let textAfter = state.sliceDoc(range.to, range.to + SearchMargin);
        let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
        let beforeOff = textBefore.length - spaceBefore;
        if (textBefore.slice(beforeOff - this.open.length, beforeOff) == this.open &&
            textAfter.slice(spaceAfter, spaceAfter + this.close.length) == this.close) {
            return { open: { pos: range.from - spaceBefore, margin: spaceBefore && 1 },
                close: { pos: range.to + spaceAfter, margin: spaceAfter && 1 } };
        }
        let startText, endText;
        if (range.to - range.from <= 2 * SearchMargin) {
            startText = endText = state.sliceDoc(range.from, range.to);
        }
        else {
            startText = state.sliceDoc(range.from, range.from + SearchMargin);
            endText = state.sliceDoc(range.to - SearchMargin, range.to);
        }
        let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
        let endOff = endText.length - endSpace - this.close.length;
        if (startText.slice(startSpace, startSpace + this.open.length) == this.open &&
            endText.slice(endOff, endOff + this.close.length) == this.close) {
            return { open: { pos: range.from + startSpace + this.open.length,
                    margin: /\s/.test(startText.charAt(startSpace + this.open.length)) ? 1 : 0 },
                close: { pos: range.to - endSpace - this.close.length,
                    margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
        }
        return null;
    }
}
const SearchMargin = 50;
// This class performs toggle, comment and uncomment
// of line comments in languages that support them.
// The `lineCommentToken` argument refer to the token of
// which this `LineCommenter` is made up.
class LineCommenter {
    constructor(lineCommentToken, margin = " ") {
        this.lineCommentToken = lineCommentToken;
        this.margin = margin;
    }
    toggle(option, state) {
        const linesAcrossSelection = [];
        const linesAcrossRange = {};
        for (let i = 0; i < state.selection.ranges.length; i++) {
            const lines = getLinesInRange(state.doc, state.selection.ranges[i]);
            linesAcrossSelection.push(...lines);
            linesAcrossRange[i] = lines;
        }
        const column = this.isRangeCommented(state, linesAcrossSelection);
        if (column.isRangeLineSkipped) {
            if (option != CommentOption.OnlyComment) {
                let changes = [];
                for (let i = 0; i < state.selection.ranges.length; i++) {
                    const lines = linesAcrossRange[i];
                    for (const line of lines) {
                        if (lines.length > 1 && column.isLineSkipped[line.number])
                            continue;
                        const pos = line.from + column.minCol;
                        const posAfter = column.minCol + this.lineCommentToken.length;
                        const marginLen = line.slice(posAfter, posAfter + 1) == " " ? 1 : 0;
                        changes.push({ from: pos, to: pos + this.lineCommentToken.length + marginLen });
                    }
                }
                return state.update({ changes });
            }
        }
        else {
            if (option != CommentOption.OnlyUncomment) {
                let changes = [];
                for (let i = 0; i < state.selection.ranges.length; i++) {
                    const lines = linesAcrossRange[i];
                    for (const line of lines) {
                        if (lines.length <= 1 || !column.isLineSkipped[line.number])
                            changes.push({ from: line.from + column.minCol, insert: this.lineCommentToken + this.margin });
                    }
                }
                return state.update({ changes });
            }
        }
        return null;
    }
    isRangeCommented(_state, lines) {
        let minCol = Infinity;
        let isRangeLineDiscarded = true;
        const isLineSkipped = [];
        for (const line of lines) {
            const str = line.slice(0, Math.min(line.length, SearchMargin));
            const col = /^\s*/.exec(str)[0].length;
            if ((lines.length == 1 || col < str.length) && col < minCol) {
                minCol = col;
            }
            if (isRangeLineDiscarded && (lines.length == 1 || col < str.length) &&
                str.slice(col, col + this.lineCommentToken.length) != this.lineCommentToken) {
                isRangeLineDiscarded = false;
            }
            isLineSkipped[line.number] = col == str.length;
        }
        return { minCol: minCol, isRangeLineSkipped: isRangeLineDiscarded, isLineSkipped: isLineSkipped };
    }
}
// Computes the lines spanned by `range`.
/// @internal
function getLinesInRange(doc, range) {
    let line = doc.lineAt(range.from);
    const lines = [];
    while (line.from + line.length < range.to ||
        (line.from <= range.to && range.to <= line.to)) {
        lines.push(line);
        if (line.number + 1 <= doc.lines) {
            line = doc.line(line.number + 1);
        }
        else {
            break;
        }
    }
    return lines;
}

export { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleLineComment };
