import { NodeProp, Tree } from 'lezer-tree';
import { IndentContext, EditorState, StateEffect, Facet, languageDataProp, StateField } from '@codemirror/next/state';
import { ViewPlugin } from '@codemirror/next/view';

/// A syntax tree node prop used to associate indentation strategies
/// with node types. Such a strategy is a function from an indentation
/// context to a number. That number may be -1, to indicate that no
/// definitive indentation can be determined, or a column number to
/// which the given line should be indented.
const indentNodeProp = new NodeProp();
function syntaxIndentation(syntax) {
    return EditorState.indentation.of((cx, pos) => {
        return computeIndentation(cx, syntax.getTree(cx.state), pos);
    });
}
// Compute the indentation for a given position from the syntax tree.
function computeIndentation(cx, ast, pos) {
    let tree = ast.resolve(pos);
    // Enter previous nodes that end in empty error terms, which means
    // they were broken off by error recovery, so that indentation
    // works even if the constructs haven't been finished.
    for (let scan = tree, scanPos = pos;;) {
        let last = scan.childBefore(scanPos);
        if (!last)
            break;
        if (last.type.prop(NodeProp.error) && last.start == last.end) {
            tree = scan;
            scanPos = last.start;
        }
        else {
            scan = last;
            scanPos = scan.end + 1;
        }
    }
    for (; tree; tree = tree.parent) {
        let strategy = indentStrategy(tree);
        if (strategy)
            return strategy(new TreeIndentContext(cx, pos, tree));
    }
    return -1;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed ? last.start : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function topIndent() { return 0; }
/// Objects of this type provide context information and helper
/// methods to indentation functions.
class TreeIndentContext extends IndentContext {
    /// @internal
    constructor(base, 
    /// The position at which indentation is being computed.
    pos, 
    /// The syntax tree node for which the indentation strategy is
    /// registered.
    node) {
        super(base.state, base.overrideIndentation, base.simulateBreak);
        this.pos = pos;
        this.node = node;
    }
    /// Get the text directly after `this.pos`, either the entire line
    /// or the next 100 characters, whichever is shorter.
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    /// Get the indentation at the reference line for `this.node`, which
    /// is the line on which it starts, unless there is a node that is
    /// _not_ a parent of this node covering the start of that line. If
    /// so, the line at the start of that node is tried, again skipping
    /// on if it is covered by another such node.
    get baseIndent() {
        let line = this.state.doc.lineAt(this.node.start);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = this.node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.start == atBreak.start)
                atBreak = atBreak.parent;
            if (isParent(atBreak, this.node))
                break;
            line = this.state.doc.lineAt(atBreak.start);
        }
        return this.lineIndent(line);
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.start), last = tree.lastChild;
    if (!openToken || context.simulateBreak == openToken.end)
        return null;
    let openLine = context.state.doc.lineAt(openToken.start);
    for (let pos = openToken.end;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.prop(NodeProp.skipped))
            return next.start < openLine.to ? openToken : null;
        pos = next.end;
    }
}
/// An indentation strategy for delimited (usually bracketed) nodes.
/// Will, by default, indent one unit more than the parent's base
/// indent unless the line starts with a closing token. When `align`
/// is true and there are non-skipped nodes on the node's opening
/// line, the content of the node will be aligned with the end of the
/// opening node, like this:
///
///     foo(bar,
///         baz)
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.start) : context.column(aligned.end);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
/// An indentation strategy that aligns a node content to its base
/// indentation.
const flatIndent = (context) => context.baseIndent;
/// Creates an indentation strategy that, by default, indents
/// continued lines one unit more than the node's base indentation.
/// You can provide `except` to prevent indentation of lines that
/// match a pattern (for example `/^else\b/` in `if`/`else`
/// constructs), and you can change the amount of units used with the
/// `units` option.
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}

/// This node prop is used to associate folding information with node
/// types. Given a subtree, it should check whether that tree is
/// foldable and return the range that can be collapsed when it is.
const foldNodeProp = new NodeProp();
function syntaxFolding(syntax) {
    return EditorState.foldable.of((state, start, end) => {
        let inner = syntax.getTree(state).resolve(end);
        let found = null;
        for (let cur = inner; cur; cur = cur.parent) {
            if (cur.end <= end || cur.start > end)
                continue;
            if (found && cur.start < start)
                break;
            let prop = cur.type.prop(foldNodeProp);
            if (prop) {
                let value = prop(cur, state);
                if (value && value.from <= end && value.from >= start && value.to > end)
                    found = value;
            }
        }
        return found;
    });
}

/// A [syntax provider](#state.Syntax) based on a
/// [Lezer](https://lezer.codemirror.net) parser.
class LezerSyntax {
    /// Create a syntax instance for the given parser. You'll usually
    /// want to use the
    /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)
    /// method to register CodeMirror-specific syntax node props in the
    /// parser, before passing it to this constructor.
    ///
    /// When [language data](#state.EditorState.languageDataAt) is
    /// given, it will be included in the syntax object's extension.
    constructor(parser, config = {}) {
        let setSyntax = StateEffect.define();
        let { languageData } = config;
        this.languageData = Facet.define({
            combine: languageData ? values => values.concat(languageData) : undefined
        });
        parser = this.parser = parser.withProps(languageDataProp.add({ [parser.topType.name]: this.languageData }));
        this.field = StateField.define({
            create(state) { return SyntaxState.advance(Tree.empty, parser, state.doc); },
            update(value, tr) { return value.apply(tr, parser, setSyntax); }
        });
        this.extension = [
            EditorState.syntax.of(this),
            this.field,
            ViewPlugin.define(view => new HighlightWorker(view, this, setSyntax)),
            syntaxIndentation(this),
            syntaxFolding(this)
        ];
    }
    getTree(state) {
        return state.field(this.field).tree;
    }
    parsePos(state) {
        return state.field(this.field).upto;
    }
    ensureTree(state, upto, timeout = 100) {
        let field = state.field(this.field);
        if (field.upto >= upto)
            return field.updatedTree;
        if (!field.parse)
            field.startParse(this.parser, state.doc);
        if (field.parse.pos < upto) {
            let done = work(field.parse, timeout, upto);
            if (done)
                return field.stopParse(done, state.doc.length);
        }
        return field.parse.pos < upto ? null : field.stopParse();
    }
    languageDataFacetAt(state, pos) {
        if (this.parser.hasNested) {
            let tree = this.getTree(state);
            let target = tree.resolve(pos);
            while (target) {
                let facet = target.type.prop(languageDataProp);
                if (facet)
                    return facet;
                target = target.parent;
            }
        }
        return this.languageData;
    }
}
class DocStream {
    constructor(doc, length = doc.length) {
        this.doc = doc;
        this.length = length;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    get(pos) {
        if (pos >= this.length)
            return -1;
        let stringStart = this.cursorPos - this.string.length;
        if (pos < stringStart || pos >= this.cursorPos) {
            if (pos < this.cursorPos) { // Reset the cursor if we have to go back
                this.cursor = this.doc.iter();
                this.cursorPos = 0;
            }
            this.string = this.cursor.next(pos - this.cursorPos).value;
            this.cursorPos = pos + this.string.length;
            stringStart = this.cursorPos - this.string.length;
        }
        return this.string.charCodeAt(pos - stringStart);
    }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
    clip(at) {
        return new DocStream(this.doc, at);
    }
}
function work(parse, time, upto = 5000000 /* MaxPos */) {
    let endTime = Date.now() + time;
    for (;;) {
        let done = parse.advance();
        if (done)
            return done;
        if (parse.pos > upto || Date.now() > endTime)
            return null;
    }
}
function takeTree(parse, base) {
    let parsed = parse.forceFinish();
    let cache = parsed.applyChanges([{ fromA: parse.pos, toA: parsed.length, fromB: parse.pos, toB: parsed.length }])
        .append(base.applyChanges([{ fromA: 0, toA: parse.pos, fromB: 0, toB: parse.pos }]));
    return { parsed, cache };
}
class SyntaxState {
    constructor(
    // The current tree. Immutable, because directly accessible from
    // the editor state.
    tree, 
    // The point upto which the document has been parsed.
    upto, 
    // The tree that can be used as cache for further incremental
    // parsing. May differ from tree/updatedTree if a parse is broken
    // off halfway—in that case, this one will have nodes that touch
    // the break-off point dropped/decomposed so that they don't get
    // incorrectly reused. The other properties will have those nodes,
    // since they may be useful for code consuming the tree.
    cache) {
        this.tree = tree;
        this.upto = upto;
        this.cache = cache;
        // In-progress parse, if any
        this.parse = null;
        this.updatedTree = tree;
    }
    static advance(cache, parser, doc) {
        let parse = parser.startParse(new DocStream(doc), { cache });
        let done = work(parse, 25 /* Apply */);
        if (done)
            return new SyntaxState(done, doc.length, done);
        let result = takeTree(parse, cache);
        return new SyntaxState(result.parsed, parse.pos, result.cache);
    }
    apply(tr, parser, effect) {
        for (let e of tr.effects)
            if (e.is(effect))
                return e.value;
        if (!tr.docChanged)
            return this;
        let ranges = [];
        tr.changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        return SyntaxState.advance((this.parse ? takeTree(this.parse, this.updatedTree).cache : this.cache).applyChanges(ranges), parser, tr.state.doc);
    }
    startParse(parser, doc) {
        this.parse = parser.startParse(new DocStream(doc), { cache: this.cache });
    }
    stopParse(tree, upto) {
        if (!tree)
            ({ parsed: tree, cache: this.cache } = takeTree(this.parse, this.updatedTree));
        else
            this.cache = tree;
        this.updatedTree = tree;
        this.upto = upto !== null && upto !== void 0 ? upto : this.parse.pos;
        this.parse = null;
        return tree;
    }
}
let requestIdle = typeof window != "undefined" && window.requestIdleCallback ||
    ((callback, { timeout }) => setTimeout(callback, timeout));
let cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
// FIXME figure out some way to back off from full re-parses when the
// document is large—you could waste a lot of battery re-parsing a
// multi-megabyte document every time you insert a backtick, even if
// it happens in the background.
class HighlightWorker {
    constructor(view, syntax, setSyntax) {
        this.view = view;
        this.syntax = syntax;
        this.setSyntax = setSyntax;
        this.working = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        if (update.docChanged)
            this.scheduleWork();
    }
    scheduleWork() {
        if (this.working > -1)
            return;
        let { state } = this.view, field = state.field(this.syntax.field);
        if (field.upto >= state.doc.length)
            return;
        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });
    }
    work(deadline) {
        this.working = -1;
        let { state } = this.view, field = state.field(this.syntax.field);
        if (field.upto >= state.doc.length)
            return;
        if (!field.parse)
            field.startParse(this.syntax.parser, state.doc);
        let done = work(field.parse, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);
        if (done || field.parse.badness > .8) {
            let tree = field.stopParse(done, state.doc.length);
            this.view.dispatch({
                effects: this.setSyntax.of(new SyntaxState(tree, state.doc.length, field.cache))
            });
        }
        else {
            this.scheduleWork();
        }
    }
    destroy() {
        if (this.working >= 0)
            cancelIdle(this.working);
    }
}

export { LezerSyntax, TreeIndentContext, continuedIndent, delimitedIndent, flatIndent, foldNodeProp, indentNodeProp };
