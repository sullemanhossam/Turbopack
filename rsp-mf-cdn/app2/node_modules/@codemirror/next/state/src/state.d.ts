import { Text } from "@codemirror/next/text";
import { ChangeSet, ChangeSpec } from "./change";
import { Tree } from "lezer-tree";
import { EditorSelection, SelectionRange } from "./selection";
import { Transaction, TransactionSpec, StrictTransactionSpec } from "./transaction";
import { Syntax, IndentContext } from "./extension";
import { Facet, Extension, StateField } from "./facet";
import { CharCategory } from "./charcategory";
export interface EditorStateConfig {
    doc?: string | Text;
    selection?: EditorSelection | {
        anchor: number;
        head?: number;
    };
    extensions?: Extension;
}
export declare class EditorState {
    readonly doc: Text;
    readonly selection: EditorSelection;
    field<T>(field: StateField<T>): T;
    field<T>(field: StateField<T>, require: false): T | undefined;
    update(...specs: readonly TransactionSpec[]): Transaction;
    replaceSelection(text: string | Text): StrictTransactionSpec;
    changeByRange(f: (range: SelectionRange) => {
        changes?: ChangeSpec;
        range: SelectionRange;
    }): StrictTransactionSpec;
    changes(spec?: ChangeSpec): ChangeSet;
    toText(string: string): Text;
    sliceDoc(from?: number, to?: number): string;
    facet<Output>(facet: Facet<any, Output>): Output;
    toJSON(): any;
    static fromJSON(json: any, config?: EditorStateConfig): EditorState;
    static create(config?: EditorStateConfig): EditorState;
    static allowMultipleSelections: Facet<boolean, boolean>;
    static indentation: Facet<(context: IndentContext, pos: number) => number, readonly ((context: IndentContext, pos: number) => number)[]>;
    static tabSize: Facet<number, number>;
    get tabSize(): number;
    static lineSeparator: Facet<string, string | undefined>;
    get lineBreak(): string;
    static indentUnit: Facet<string, string>;
    get indentUnit(): number;
    get indentWithTabs(): boolean;
    static phrases: Facet<{
        [key: string]: string;
    }, readonly {
        [key: string]: string;
    }[]>;
    phrase(phrase: string): string;
    static syntax: Facet<Syntax, readonly Syntax[]>;
    charCategorizer(at: number): (char: string) => CharCategory;
    get tree(): Tree;
    static globalLanguageData: Facet<{
        [name: string]: any;
    }, readonly {
        [name: string]: any;
    }[]>;
    languageDataAt<T>(name: string, pos: number): readonly T[];
    static foldable: Facet<(state: EditorState, lineStart: number, lineEnd: number) => ({
        from: number;
        to: number;
    } | null), readonly ((state: EditorState, lineStart: number, lineEnd: number) => ({
        from: number;
        to: number;
    } | null))[]>;
    static changeFilter: Facet<(tr: StrictTransactionSpec, state: EditorState) => boolean | readonly number[], readonly ((tr: StrictTransactionSpec, state: EditorState) => boolean | readonly number[])[]>;
    static transactionFilter: Facet<(tr: StrictTransactionSpec, oldState: EditorState, finish: () => Transaction) => TransactionSpec | readonly TransactionSpec[], readonly ((tr: StrictTransactionSpec, oldState: EditorState, finish: () => Transaction) => TransactionSpec | readonly TransactionSpec[])[]>;
}
//# sourceMappingURL=state.d.ts.map