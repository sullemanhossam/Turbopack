import { Stack } from "./stack";
import { InputStream, Token, Tokenizer, TokenGroup } from "./token";
import { Tree, TreeBuffer, NodeGroup, NodeType, NodeProp, NodePropSource } from "lezer-tree";
export declare type NestedGrammar = null | Parser | ((input: InputStream, stack: Stack) => NestedGrammarSpec);
export interface NestedGrammarSpec {
    parser?: Parser;
    top?: string;
    stay?: boolean;
    parseNode?: (input: InputStream, start: number) => Tree;
    wrapType?: number;
    filterEnd?: (endToken: string) => boolean;
}
declare class CachedToken extends Token {
    extended: number;
    mask: number;
    clear(start: number): void;
}
declare class TokenCache {
    tokens: CachedToken[];
    mainToken: Token;
    actions: number[];
    constructor(parser: Parser);
    getActions(stack: Stack, input: InputStream): number[];
    updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: InputStream): void;
    putAction(action: number, token: number, end: number, index: number): number;
    addActions(stack: Stack, token: number, end: number, index: number): number;
}
export interface ParseOptions {
    cache?: Tree;
    strict?: boolean;
    bufferLength?: number;
    top?: string;
}
export declare class StackContext {
    readonly parser: Parser;
    readonly maxBufferLength: number;
    readonly input: InputStream;
    readonly topTerm: number;
    readonly parent: Stack | null;
    wrapType: number;
    reused: (Tree | TreeBuffer)[];
    tokens: TokenCache;
    constructor(parser: Parser, maxBufferLength: number, input: InputStream, topTerm: number, parent?: Stack | null, wrapType?: number);
}
export declare class ParseContext {
    private stacks;
    pos: number;
    private recovering;
    private tokenCount;
    private cache;
    private strict;
    constructor(parser: Parser, input: InputStream, { cache, strict, bufferLength, top }?: ParseOptions);
    putStack(stack: Stack): void;
    advance(): Tree;
    private advanceStack;
    private advanceFully;
    private runRecovery;
    forceFinish(): Tree;
    get badness(): number;
    private scanForNestEnd;
}
export declare class Parser {
    readonly states: Readonly<Uint32Array>;
    readonly data: Readonly<Uint16Array>;
    readonly goto: Readonly<Uint16Array>;
    readonly group: NodeGroup;
    readonly minRepeatTerm: number;
    readonly tokenizers: readonly Tokenizer[];
    readonly topRules: {
        [name: string]: [number, number];
    };
    readonly nested: readonly {
        name: string;
        grammar: NestedGrammar;
        end: TokenGroup;
        placeholder: number;
    }[];
    readonly specializeTable: number;
    readonly specializations: readonly {
        [value: string]: number;
    }[];
    readonly tokenPrecTable: number;
    readonly termNames: null | {
        [id: number]: string;
    };
    maxNode: number;
    maxRepeatWrap: number;
    private nextStateCache;
    constructor(states: Readonly<Uint32Array>, data: Readonly<Uint16Array>, goto: Readonly<Uint16Array>, group: NodeGroup, minRepeatTerm: number, tokenizers: readonly Tokenizer[], topRules: {
        [name: string]: [number, number];
    }, nested: readonly {
        name: string;
        grammar: NestedGrammar;
        end: TokenGroup;
        placeholder: number;
    }[], specializeTable: number, specializations: readonly {
        [value: string]: number;
    }[], tokenPrecTable: number, termNames?: null | {
        [id: number]: string;
    });
    parse(input: InputStream | string, options?: ParseOptions): Tree;
    startParse(input: InputStream | string, options?: ParseOptions): ParseContext;
    getGoto(state: number, term: number, loose?: boolean): number;
    hasAction(state: number, terminal: number): number;
    stateSlot(state: number, slot: number): number;
    stateFlag(state: number, flag: number): boolean;
    startNested(state: number): number;
    validAction(state: number, action: number): boolean;
    nextStates(state: number): readonly number[];
    overrides(token: number, prev: number): boolean;
    withNested(spec: {
        [name: string]: NestedGrammar | null;
    }): Parser;
    withProps(...props: NodePropSource[]): Parser;
    getName(term: number): string;
    get eofTerm(): number;
    get hasNested(): boolean;
    get defaultTop(): [number, number];
    get topType(): NodeType;
    static deserialize(spec: {
        states: string;
        stateData: string;
        goto: string;
        nodeNames: string;
        repeatNodeCount: number;
        nodeProps?: [NodeProp<any>, ...(string | number)[]][];
        tokenData: string;
        tokenizers: (Tokenizer | number)[];
        topRules: {
            [name: string]: [number, number];
        };
        nested?: [string, null | NestedGrammar, string, number][];
        specializeTable: number;
        specializations?: readonly {
            [term: string]: number;
        }[];
        tokenPrec: number;
        termNames?: {
            [id: number]: string;
        };
    }): Parser;
}
export {};
