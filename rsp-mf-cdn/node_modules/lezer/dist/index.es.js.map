{"version":3,"file":"index.es.js","sources":["../../node_modules/tslib/tslib.es6.js","../src/stack.ts","../src/token.ts","../src/decode.ts","../src/parse.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {Action, Term, StateFlag, ParseState} from \"./constants\"\nimport {StackContext} from \"./parse\"\nimport {Tree, TreeBuffer, BufferCursor} from \"lezer-tree\"\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nexport class Stack {\n  /// @internal\n  constructor(\n    // A group of values that the stack will share with all\n    // split instances\n    ///@internal\n    readonly cx: StackContext,\n    // Holds state, pos, value stack pos (15 bits array index, 15 bits\n    // buffer index) triplets for all but the top state\n    /// @internal\n    readonly stack: number[],\n    // The current parse state\n    /// @internal\n    public state: number,\n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    public reducePos: number,\n    // The input position up to which this stack has parsed.\n    public pos: number,\n    // The amount of error-recovery that happened on this stack\n    /// @internal\n    public recovered: number,\n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    readonly buffer: number[],\n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    readonly bufferBase: number,\n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    readonly parent: Stack | null\n  ) {}\n\n  /// @internal\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.recovered ? \"!\" + this.recovered : \"\"}`\n  }\n\n  // Start an empty stack\n  /// @internal\n  static start(cx: StackContext, state: number, pos = 0) {\n    return new Stack(cx, [], state, pos, pos, 0, [], 0, null)\n  }\n\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /// @internal\n  pushState(state: number, start: number) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length)\n    this.state = state\n  }\n\n  // Apply a reduce action\n  /// @internal\n  reduce(action: number) {\n    let depth = action >> Action.ReduceDepthShift, type = action & Action.ValueMask\n    let {parser} = this.cx\n    if (depth == 0) {\n      // Zero-depth reductions are a special case—they add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true)\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos)\n      return\n    }\n\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - ((depth - 1) * 3) - (action & Action.StayFlag ? 6 : 0)\n    let start = this.stack[base - 2]\n    let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase\n    if (type < parser.minRepeatTerm || // Normal term\n        (action & Action.RepeatFlag) || // Inner repeat marker\n        (type > parser.maxNode && type <= parser.maxRepeatWrap)) { // Repeat wrapper\n      let pos = parser.stateFlag(this.state, StateFlag.Skipped) ? this.pos : this.reducePos\n      this.storeNode(type, start, pos, count + 4, true)\n    }\n    if (action & Action.StayFlag) {\n      this.state = this.stack[base]\n    } else {\n      let baseStateID = this.stack[base - 3]\n      this.state = parser.getGoto(baseStateID, type, true)\n    }\n    while (this.stack.length > base) this.stack.pop()\n  }\n\n  // Shift a value into the buffer\n  /// @internal\n  storeNode(term: number, start: number, end: number, size = 4, isReduce = false) {\n    if (term == Term.Err) { // Try to omit/merge adjacent error nodes\n      let cur: Stack | null = this, top = this.buffer.length\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase\n        cur = cur.parent\n      }\n      if (top > 0 && cur.buffer[top - 4] == Term.Err && cur.buffer[top - 1] > -1) {\n        if (start == end) return\n        if (cur.buffer[top - 2] >= start) { cur.buffer[top - 2] = end; return }\n      }\n    }\n\n    if (!isReduce || this.pos == end) { // Simple case, just append\n      this.buffer.push(term, start, end, size)\n    } else { // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length\n      if (index > 0 && this.buffer[index - 4] != Term.Err) while (index > 0 && this.buffer[index - 2] > end) {\n        // Move this record forward\n        this.buffer[index] = this.buffer[index - 4]\n        this.buffer[index + 1] = this.buffer[index - 3]\n        this.buffer[index + 2] = this.buffer[index - 2]\n        this.buffer[index + 3] = this.buffer[index - 1]\n        index -= 4\n        if (size > 4) size -= 4\n      }\n      this.buffer[index] = term\n      this.buffer[index + 1] = start\n      this.buffer[index + 2] = end\n      this.buffer[index + 3] = size\n    }\n  }\n\n  // Apply a shift action\n  /// @internal\n  shift(action: number, next: number, nextEnd: number) {\n    if (action & Action.GotoFlag) {\n      this.pushState(action & Action.ValueMask, this.pos)\n    } else if ((action & Action.StayFlag) == 0) { // Regular shift\n      let start = this.pos, nextState = action, {parser} = this.cx\n      if (nextEnd > this.pos || next <= parser.maxNode) {\n        this.pos = nextEnd\n        if (!parser.stateFlag(nextState, StateFlag.Skipped)) this.reducePos = nextEnd\n      }\n      this.pushState(nextState, start)\n      if (next <= parser.maxNode) this.buffer.push(next, start, nextEnd, 4)\n    } else { // Shift-and-stay, which means this is a skipped token\n      if (next <= this.cx.parser.maxNode) this.buffer.push(next, this.pos, nextEnd, 4)\n      this.pos = nextEnd\n    }\n  }\n\n  // Apply an action\n  /// @internal\n  apply(action: number, next: number, nextEnd: number) {\n    if (action & Action.ReduceFlag) this.reduce(action)\n    else this.shift(action, next, nextEnd)\n  }\n\n  // Add a prebuilt node into the buffer. This may be a reused node or\n  // the result of running a nested parser.\n  /// @internal\n  useNode(value: Tree | TreeBuffer, next: number) {\n    let index = this.cx.reused.length - 1\n    if (index < 0 || this.cx.reused[index] != value) {\n      this.cx.reused.push(value)\n      index++\n    }\n    let start = this.pos\n    this.reducePos = this.pos = start + value.length\n    this.pushState(next, start)\n    this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */)\n  }\n\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /// @internal\n  split() {\n    let parent: Stack | null = this\n    let off = parent.buffer.length\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4\n    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent\n    return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos,\n                     this.recovered, buffer, base, parent)\n  }\n\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /// @internal\n  recoverByDelete(next: number, nextEnd: number) {\n    let isNode = next <= this.cx.parser.maxNode\n    if (isNode) this.storeNode(next, this.pos, nextEnd)\n    this.storeNode(Term.Err, this.pos, nextEnd, isNode ? 8 : 4)\n    this.pos = this.reducePos = nextEnd\n    this.recovered += Recover.Token\n  }\n\n  /// Check if the given term would be able to be shifted (optionally\n  /// after some reductions) on this stack. This can be useful for\n  /// external tokenizers that want to make sure they only provide a\n  /// given token when it applies.\n  canShift(term: number) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.cx.parser.stateSlot(sim.top, ParseState.DefaultReduce) || this.cx.parser.hasAction(sim.top, term)\n      if ((action & Action.ReduceFlag) == 0) return true\n      if (action == 0) return false\n      sim.reduce(action)\n    }\n  }\n\n  /// Find the start position of the rule that is currently being parsed.\n  get ruleStart() {\n    let force = this.cx.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if (!(force & Action.ReduceFlag)) return 0\n    let base = this.stack.length - (3 * (force >> Action.ReduceDepthShift))\n    return this.stack[base + 1]\n  }\n\n  /// Find the start position of the innermost instance of any of the\n  /// given term types, or return `-1` when none of them are found.\n  ///\n  /// **Note:** this is only reliable when there is at least some\n  /// state that unambiguously matches the given rule on the stack.\n  /// I.e. if you have a grammar like this, where the difference\n  /// between `a` and `b` is only apparent at the third token:\n  ///\n  ///     a { b | c }\n  ///     b { \"x\" \"y\" \"x\" }\n  ///     c { \"x\" \"y\" \"z\" }\n  ///\n  /// Then a parse state after `\"x\"` will not reliably tell you that\n  /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n  /// for either of those two rules (assuming that `a` isn't part of\n  /// some rule that includes other things starting with `\"x\"`).\n  startOf(types: readonly number[]) {\n    let state = this.state, frame = this.stack.length, {parser} = this.cx\n    for (;;) {\n      let force = parser.stateSlot(state, ParseState.ForcedReduce)\n      let depth = force >> Action.ReduceDepthShift, term = force & Action.ValueMask\n      if (types.indexOf(term) > -1) {\n        let base = frame - (3 * (force >> Action.ReduceDepthShift))\n        return this.stack[base + 1]\n      }\n      if (frame == 0) return -1\n      if (depth == 0) {\n        frame -= 3\n        state = this.stack[frame]\n      } else {\n        frame -= 3 * (depth - 1)\n        state = parser.getGoto(this.stack[frame - 3], term, true)\n      }\n    }\n  }\n\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /// @internal\n  recoverByInsert(next: number): Stack[] {\n    let nextStates = this.cx.parser.nextStates(this.state)\n    if (nextStates.length > Recover.MaxNext) {\n      let best = nextStates.filter(s => s != this.state && this.cx.parser.hasAction(s, next))\n      for (let i = 0; best.length < Recover.MaxNext && i < nextStates.length; i++)\n        if (best.indexOf(nextStates[i]) < 0) best.push(nextStates[i])\n      nextStates = best\n    }\n    let result: Stack[] = []\n    for (let i = 0; i < nextStates.length && result.length < Recover.MaxNext; i++) {\n      if (nextStates[i] == this.state) continue\n      let stack = this.split()\n      stack.storeNode(Term.Err, stack.pos, stack.pos, 4, true)\n      stack.pushState(nextStates[i], this.pos)\n      stack.recovered += Recover.Token\n      result.push(stack)\n    }\n    return result\n  }\n\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /// @internal\n  forceReduce() {\n    let reduce = this.cx.parser.stateSlot(this.state, ParseState.ForcedReduce)\n    if ((reduce & Action.ReduceFlag) == 0) return false\n    if (!this.cx.parser.validAction(this.state, reduce)) {\n      this.storeNode(Term.Err, this.reducePos, this.reducePos, 4, true)\n      this.recovered += Recover.Reduce\n    }\n    this.reduce(reduce)\n    return true\n  }\n\n  /// @internal\n  forceAll() {\n    while (!this.cx.parser.stateFlag(this.state, StateFlag.Accepting) && this.forceReduce()) {}\n    return this\n  }\n\n  // Convert the stack's buffer to a syntax tree.\n  /// @internal\n  toTree(): Tree {\n    return Tree.build({buffer: StackBufferCursor.create(this),\n                       group: this.cx.parser.group,\n                       topID: this.cx.topTerm,\n                       maxBufferLength: this.cx.maxBufferLength,\n                       reused: this.cx.reused,\n                       minRepeatType: this.cx.parser.minRepeatTerm})\n  }\n}\n\nexport const enum Recover {\n  Token = 2,\n  Reduce = 1,\n  MaxNext = 4\n}\n\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  top: number\n  rest: number[]\n  offset: number\n\n  constructor(readonly stack: Stack) {\n    this.top = stack.state\n    this.rest = stack.stack\n    this.offset = this.rest.length\n  }\n\n  reduce(action: number) {\n    let term = action & Action.ValueMask, depth = action >> Action.ReduceDepthShift\n    if (depth == 0) {\n      if (this.rest == this.stack.stack) this.rest = this.rest.slice()\n      this.rest.push(this.top, 0, 0)\n      this.offset += 3\n    } else {\n      this.offset -= (depth - 1) * 3\n    }\n    let goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true)\n    this.top = goto\n  }\n}\n\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor implements BufferCursor {\n  buffer: number[]\n\n  constructor(public stack: Stack, public pos: number, public index: number) {\n    this.buffer = stack.buffer\n    if (this.index == 0) this.maybeNext()\n  }\n\n  static create(stack: Stack) {\n    return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length)\n  }\n\n  maybeNext() {\n    let next = this.stack.parent\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase\n      this.stack = next\n      this.buffer = next.buffer\n    }\n  }\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  next() {\n    this.index -= 4\n    this.pos -= 4\n    if (this.index == 0) this.maybeNext()\n  }\n\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index)\n  }\n}\n","import {Stack} from \"./stack\"\n\n/// Tokenizers write the tokens they read into instances of this class.\nexport class Token {\n  /// The start of the token. This is set by the parser, and should not\n  /// be mutated by the tokenizer.\n  start = -1\n  /// This starts at -1, and should be updated to a term id when a\n  /// matching token is found.\n  value = -1\n  /// When setting `.value`, you should also set `.end` to the end\n  /// position of the token. (You'll usually want to use the `accept`\n  /// method.)\n  end = -1\n\n  /// Accept a token, setting `value` and `end` to the given values.\n  accept(value: number, end: number) {\n    this.value = value\n    this.end = end\n  }\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code points. Most access will be\n/// sequential, so implementations can optimize for that.\nexport interface InputStream {\n  /// The end of the stream.\n  length: number\n  /// Get the code point at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream\n  get(pos: number): number\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `InputStream` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): InputStream\n}\n\n/// An `InputStream` that is backed by a single, flat string.\nexport class StringStream implements InputStream {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringStream(this.string, at) }\n}\n\nexport interface Tokenizer {\n  token(input: InputStream, token: Token, stack: Stack): void\n  contextual: boolean\n}\n\n/// @internal\nexport class TokenGroup implements Tokenizer {\n  contextual!: boolean\n\n  constructor(readonly data: Readonly<Uint16Array>, readonly id: number) {}\n\n  token(input: InputStream, token: Token, stack: Stack) { readToken(this.data, input, token, stack, this.id) }\n}\n\nTokenGroup.prototype.contextual = false\n\nexport class ExternalTokenizer {\n  contextual: boolean\n\n  constructor(readonly token: (input: InputStream, token: Token, stack: Stack) => void,\n              options: {contextual?: boolean} = {}) {\n    this.contextual = options && options.contextual || false\n  }\n}\n\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data: Readonly<Uint16Array>,\n                   input: InputStream,\n                   token: Token,\n                   stack: Stack,\n                   group: number) {\n  let state = 0, groupMask = 1 << group\n  scan: for (let pos = token.start;;) {\n    if ((groupMask & data[state]) == 0) break\n    let accEnd = data[state + 1]\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i]\n      if (token.value == -1 || token.value == term || stack.cx.parser.overrides(term, token.value)) {\n        token.accept(term, pos)\n        break\n      }\n    }\n    let next = input.get(pos++)\n    // Do a binary search on the state's edges\n    for (let low = 0, high = data[state + 2]; low < high;) {\n      let mid = (low + high) >> 1\n      let index = accEnd + mid + (mid << 1)\n      let from = data[index], to = data[index + 1]\n      if (next < from) high = mid\n      else if (next >= to) low = mid + 1\n      else { state = data[index + 2]; continue scan }\n    }\n    break\n  }\n}\n","// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\n\nimport {Encode} from \"./constants\"\n\nexport function decodeArray<T extends {[i: number]: number} = Uint16Array>(input: string, Type: {new (n: number): T} = Uint16Array as any): T {\n  let array: T | null = null\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0\n    for (;;) {\n      let next = input.charCodeAt(pos++), stop = false\n      if (next == Encode.BigValCode) { value = Encode.BigVal; break }\n      if (next >= Encode.Gap2) next--\n      if (next >= Encode.Gap1) next--\n      let digit = next - Encode.Start\n      if (digit >= Encode.Base) { digit -= Encode.Base; stop = true }\n      value += digit\n      if (stop) break\n      value *= Encode.Base\n    }\n    if (array) array[out++] = value\n    else array = new Type(value)\n  }\n  return array!\n}\n","import {Stack, Recover} from \"./stack\"\nimport {Action, Specialize, Term, Seq, StateFlag, ParseState} from \"./constants\"\nimport {InputStream, Token, StringStream, Tokenizer, TokenGroup} from \"./token\"\nimport {DefaultBufferLength, Tree, TreeBuffer, NodeGroup, NodeType, NodeProp, NodePropSource} from \"lezer-tree\"\nimport {decodeArray} from \"./decode\"\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG!)\n\n/// Nested grammar values are associated with nesting positions in the\n/// grammar. If they are null, the nested region is simply skipped\n/// over. If they hold a parser object, that parser is used to parse\n/// the region. To implement dynamic behavior, the value may also be a\n/// function which returns a description of the way the region should\n/// be parsed.\nexport type NestedGrammar = null | Parser | ((input: InputStream, stack: Stack) => NestedGrammarSpec)\n\n/// An object indicating how to proceed with a nested parse.\nexport interface NestedGrammarSpec {\n  /// When given, this is used to provide a parser that should be used\n  /// to parse the content.\n  parser?: Parser\n  /// When `parser` is given, this can be used to configure which top\n  /// rule to parse with it.\n  top?: string\n  /// This being true means that the outer grammar should use\n  /// the fallback expression provided for the nesting to parse the\n  /// content.\n  stay?: boolean\n  /// Alternatively, `parseNode` may hold a function which will be made\n  /// responsible for parsing the region.\n  parseNode?: (input: InputStream, start: number) => Tree\n  /// An optional extra type to tag the resulting tree with.\n  wrapType?: number,\n  /// When a `filterEnd` property is present, that should hold a\n  /// function that determines whether a given end token (which matches\n  /// the end token specified in the grammar) should be used (true) or\n  /// ignored (false). This is mostly useful for implementing things\n  /// like XML closing tag matching.\n  filterEnd?: (endToken: string) => boolean\n}\n\nclass CacheCursor {\n  trees: Tree[]\n  start = [0]\n  index = [0]\n  nextStart: number = 0\n\n  constructor(tree: Tree) { this.trees = [tree] }\n\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos: number): Tree | TreeBuffer | null {\n    if (pos < this.nextStart) return null\n\n    for (;;) {\n      let last = this.trees.length - 1\n      if (last < 0) { // End of tree\n        this.nextStart = 1e9\n        return null\n      }\n      let top = this.trees[last], index = this.index[last]\n      if (index == top.children.length) {\n        this.trees.pop()\n        this.start.pop()\n        this.index.pop()\n        continue\n      }\n      let next = top.children[index]\n      let start = this.start[last] + top.positions[index]\n      if (start >= pos) return start == pos ? next : null\n      if (next instanceof TreeBuffer) {\n        this.index[last]++\n        this.nextStart = start + next.length\n      } else {\n        this.index[last]++\n        if (start + next.length >= pos) { // Enter this node\n          this.trees.push(next)\n          this.start.push(start)\n          this.index.push(0)\n        }\n      }\n    }\n  }\n}\n\nclass CachedToken extends Token {\n  extended = -1\n  mask = 0\n\n  clear(start: number) {\n    this.start = start\n    this.value = this.extended = -1\n  }\n}\n\nconst dummyToken = new Token\n\nclass TokenCache {\n  tokens: CachedToken[] = []\n  mainToken: Token = dummyToken\n\n  actions: number[] = []\n\n  constructor(parser: Parser) {\n    this.tokens = parser.tokenizers.map(_ => new CachedToken)\n  }\n\n  getActions(stack: Stack, input: InputStream) {\n    let actionIndex = 0\n    let main: Token | null = null\n    let {parser} = stack.cx, {tokenizers} = parser\n\n    let mask = parser.stateSlot(stack.state, ParseState.TokenizerMask)\n    for (let i = 0; i < tokenizers.length; i++) {\n      if (((1 << i) & mask) == 0) continue\n      let tokenizer = tokenizers[i], token = this.tokens[i]\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {\n        this.updateCachedToken(token, tokenizer, stack, input)\n        token.mask = mask\n      }\n\n      let startIndex = actionIndex\n      if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex)\n      actionIndex = this.addActions(stack, token.value, token.end, actionIndex)\n      if (actionIndex > startIndex) {\n        main = token\n        break\n      }\n      if (!main || token.value != Term.Err) main = token\n    }\n\n    while (this.actions.length > actionIndex) this.actions.pop()\n    if (!main) {\n      main = dummyToken\n      main.start = stack.pos\n      if (stack.pos == input.length) main.accept(stack.cx.parser.eofTerm, stack.pos)\n      else main.accept(Term.Err, stack.pos + 1)\n    }\n    this.mainToken = main\n    return this.actions\n  }\n\n  updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: InputStream) {\n    token.clear(stack.pos)\n    tokenizer.token(input, token, stack)\n    if (token.value > -1) {\n      let {parser} = stack.cx\n      let specIndex = findOffset(parser.data, parser.specializeTable, token.value)\n      if (specIndex >= 0) {\n        let found = parser.specializations[specIndex][input.read(token.start, token.end)]\n        if (found != null) {\n          if ((found & 1) == Specialize.Specialize) token.value = found >> 1\n          else token.extended = found >> 1\n        }\n      }\n    } else if (stack.pos == input.length) {\n      token.accept(stack.cx.parser.eofTerm, stack.pos)\n    } else {\n      token.accept(Term.Err, stack.pos + 1)\n    }\n  }\n\n  putAction(action: number, token: number, end: number, index: number) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index\n    this.actions[index++] = action\n    this.actions[index++] = token\n    this.actions[index++] = end\n    return index\n  }\n\n  addActions(stack: Stack, token: number, end: number, index: number) {\n    let {state} = stack, {parser} = stack.cx, {data} = parser\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next; (next = data[i]) != Seq.End; i += 3) {\n        if (next == token || (next == Term.Err && index == 0))\n          index = this.putAction(data[i + 1] | (data[i + 2] << 16), token, end, index)\n      }\n    }\n    return index\n  }\n}\n\n/// Options that can be passed to control parsing.\nexport interface ParseOptions {\n  /// Passing a cached tree is used for incremental parsing. This\n  /// should be a tree whose content is aligned with the current\n  /// document (though a call to `Tree.unchanged`) if any changes were\n  /// made since it was produced. The parser will try to reuse nodes\n  /// from this tree in the new parse, greatly speeding up the parse\n  /// when it can reuse nodes for most of the document.\n  cache?: Tree\n  /// When true, the parser will raise an exception, rather than run\n  /// its error-recovery strategies, when the input doesn't match the\n  /// grammar.\n  strict?: boolean,\n  /// The maximum length of the TreeBuffers generated in the output\n  /// tree. Defaults to 1024.\n  bufferLength?: number,\n  /// The name of the @top declaration to parse from. If not\n  /// specified, the first @top declaration is used.\n  top?: string\n}\n\nexport class StackContext {\n  reused: (Tree | TreeBuffer)[] = []\n  tokens: TokenCache\n  constructor(\n    readonly parser: Parser,\n    readonly maxBufferLength: number,\n    readonly input: InputStream,\n    readonly topTerm: number,\n    readonly parent: Stack | null = null,\n    public wrapType: number = -1 // Set to -2 when a stack descending from this nesting event finishes\n  ) {\n    this.tokens = new TokenCache(parser)\n  }\n}\n\nconst recoverDist = 5, maxRemainingPerStep = 3, minBufferLengthPrune = 200, forceReduceLimit = 10\n\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nexport class ParseContext {\n  // Active parse stacks.\n  private stacks: Stack[]\n  // The position to which the parse has advanced.\n  public pos = 0\n  private recovering = 0\n  private tokenCount = 0\n  private cache: CacheCursor | null\n  private strict: boolean\n\n  /// @internal\n  constructor(parser: Parser,\n              input: InputStream,\n              {cache = undefined, strict = false, bufferLength = DefaultBufferLength, top = undefined}: ParseOptions = {}) {\n    let topInfo = top ? parser.topRules[top] : parser.defaultTop\n    if (!topInfo) throw new RangeError(`Invalid top rule name ${top}`)\n    this.stacks = [Stack.start(new StackContext(parser, bufferLength, input, topInfo[1]), topInfo[0])]\n    this.strict = strict\n    this.cache = cache ? new CacheCursor(cache) : null\n  }\n\n  /// @internal\n  putStack(stack: Stack) {\n    this.stacks.push(stack)\n    if (this.pos < 0 || stack.pos < this.pos) this.pos = stack.pos\n  }\n\n  /// Move the parser forward. This will process all parse stacks at\n  /// `this.pos` and try to advance them to a further position. If no\n  /// stack for such a position is found, it'll start error-recovery.\n  ///\n  /// When the parse is finished, this will return a syntax tree. When\n  /// not, it returns `null`.\n  advance() {\n    let stacks = this.stacks, pos = this.pos\n    // This will now hold stacks beyond `pos`.\n    this.stacks = []\n    // Will be reset to the next position by `putStack`.\n    this.pos = -1\n    let stopped: Stack[] | null = null, stoppedTokens: number[] | null = null\n\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i]\n      for (;;) {\n        if (stack.pos > pos) {\n          this.putStack(stack)\n        } else {\n          let result = this.advanceStack(stack, stacks)\n          if (result) {\n            stack = result\n            continue\n          } else {\n            if (!stopped) { stopped = []; stoppedTokens = [] }\n            stopped.push(stack)\n            let tok = stack.cx.tokens.mainToken\n            stoppedTokens!.push(tok.value, tok.end)\n          }\n        }\n        break\n      }\n    }\n\n    if (!this.stacks.length) {\n      let finished = stopped && findFinished(stopped)\n      if (finished) return finished.toTree()\n\n      if (this.strict) throw new SyntaxError(\"No parse at \" + pos)\n      if (!this.recovering) this.recovering = recoverDist\n    }\n\n    if (this.recovering && stopped) {\n      let finished = this.runRecovery(stopped, stoppedTokens!)\n      if (finished) return finished.forceAll().toTree()\n    }\n\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * maxRemainingPerStep\n      if (this.stacks.length > maxRemaining) {\n        this.stacks.sort((a, b) => a.recovered - b.recovered)\n        this.stacks.length = maxRemaining\n      }\n      if (this.stacks.some(s => s.reducePos > pos)) this.recovering--\n    } else if (this.stacks.length > 1 && this.stacks[0].buffer.length > minBufferLengthPrune) {\n      // Prune stacks that have been running without splitting for a\n      // while, to avoid getting stuck with multiple successful stacks\n      // running endlessly on.\n      let minLen = 1e9, minI = -1\n      for (let i = 0; i < this.stacks.length; i++) {\n        let stack = this.stacks[i]\n        if (stack.buffer.length < minLen) { minLen = stack.buffer.length; minI = i }\n      }\n      if (minLen > minBufferLengthPrune) this.stacks.splice(minI, 1)\n    }\n\n    this.tokenCount++\n    return null\n  }\n\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` is given, stacks split\n  // off by ambiguous operations will be pushed to that, or given to\n  // `putStack` if they move `pos` forward.\n  private advanceStack(stack: Stack, split: null | Stack[]) {\n    let start = stack.pos, {input, parser} = stack.cx\n    let base = verbose ? stack + \" -> \" : \"\"\n\n    if (this.cache) {\n      for (let cached = this.cache.nodeAt(start); cached;) {\n        let match = parser.group.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1\n        if (match > -1) {\n          stack.useNode(cached, match)\n          if (verbose) console.log(base + stack + ` (via reuse of ${parser.getName(cached.type.id)})`)\n          return stack\n        }\n        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0) break\n        let inner = cached.children[0]\n        if (inner instanceof Tree) cached = inner\n        else break\n      }\n    }\n\n    let nest = parser.startNested(stack.state)\n    maybeNest: if (nest > -1) {\n      let {grammar, end: endToken, placeholder} = parser.nested[nest]\n      let filterEnd = undefined, parseNode = null, nested, top, wrapType = undefined\n      if (typeof grammar == \"function\") {\n        let query = grammar(input, stack)\n        if (query.stay) break maybeNest\n        ;({parseNode, parser: nested, top, filterEnd, wrapType} = query)\n      } else {\n        nested = grammar\n      }\n      let end = this.scanForNestEnd(stack, endToken, filterEnd)\n      let clippedInput = stack.cx.input.clip(end)\n      if (parseNode || !nested) {\n        let node = parseNode ? parseNode(clippedInput, stack.pos) : Tree.empty\n        if (node.length != end - stack.pos) node = new Tree(node.type, node.children, node.positions, end - stack.pos)\n        if (wrapType != null) node = new Tree(parser.group.types[wrapType], [node], [0], node.length)\n        stack.useNode(node, parser.getGoto(stack.state, placeholder, true))\n        return stack\n      } else {\n        let topInfo = top ? nested.topRules[top] : nested.defaultTop\n        let newStack = Stack.start(new StackContext(nested, stack.cx.maxBufferLength, clippedInput, topInfo[1], stack, wrapType),\n                                   topInfo[0], stack.pos)\n        if (verbose) console.log(base + newStack + ` (nested)`)\n        return newStack\n      }\n    }\n\n    let defaultReduce = parser.stateSlot(stack.state, ParseState.DefaultReduce)\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce)\n      if (verbose) console.log(base + stack + ` (via always-reduce ${parser.getName(defaultReduce & Action.ValueMask)})`)\n      return stack\n    }\n\n    let actions = stack.cx.tokens.getActions(stack, input)\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++], term = actions[i++], end = actions[i++]\n      let last = i == actions.length || !split\n      let localStack = last ? stack : stack.split()\n      localStack.apply(action, term, end)\n      if (verbose)\n        console.log(base + localStack + ` (via ${(action & Action.ReduceFlag) == 0 ? \"shift\"\n                     : `reduce of ${parser.getName(action & Action.ValueMask)}`} for ${\n        parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`)\n      if (last) return localStack\n      else if (localStack.pos > start) this.putStack(localStack)\n      else split!.push(localStack)\n    }\n\n    if (stack.cx.parent && stack.pos == input.length) return finishNested(stack)\n    return null\n  }\n\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `putStack`.\n  private advanceFully(stack: Stack) {\n    let pos = stack.pos\n    for (;;) {\n      let result = this.advanceStack(stack, null)\n      if (!result) return stack\n      if (result.pos > pos) {\n        this.putStack(result)\n        return null\n      }\n      stack = result\n    }\n  }\n\n  private runRecovery(stacks: Stack[], tokens: number[]) {\n    let finished: Stack | null = null\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1]\n      let base = verbose ? stack + \" -> \" : \"\"\n\n      let force = stack.split(), forceBase = base\n      for (let j = 0; force.forceReduce() && j < forceReduceLimit; j++) {\n        if (verbose) console.log(forceBase + force + \" (via force-reduce)\")\n        let stopped = this.advanceFully(force)\n        if (!stopped) break\n        force = stopped\n        if (verbose) forceBase = stopped + \" -> \"\n      }\n\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + insert + \" (via recover-insert)\")\n        this.advanceFully(insert)\n      }\n\n      if (stack.cx.input.length > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++\n          token = Term.Err\n        }\n        stack.recoverByDelete(token, tokenEnd)\n        if (verbose) console.log(base + stack + ` (via recover-delete ${stack.cx.parser.getName(token)})`)\n        this.putStack(stack)\n      } else if (!stack.cx.parent && (!finished || finished.recovered > stack.recovered)) {\n        finished = stack\n      }\n    }\n    return finished\n  }\n\n  /// Force the parse to finish, generating a tree containing the nodes\n  /// parsed so far.\n  forceFinish() {\n    return this.stacks[0].split().forceAll().toTree()\n  }\n\n  /// A value that indicates how successful the parse is so far, as\n  /// the number of error-recovery steps taken divided by the number\n  /// of tokens parsed. Could be used to decide to abort a parse when\n  /// the input doesn't appear to match the grammar at all.\n  get badness() {\n    return this.stacks[0].recovered * Recover.Token / this.tokenCount\n  }\n\n  private scanForNestEnd(stack: Stack, endToken: TokenGroup, filter?: ((token: string) => boolean)) {\n    let input = stack.cx.input\n    for (let pos = stack.pos; pos < input.length; pos++) {\n      dummyToken.start = pos\n      dummyToken.value = -1\n      endToken.token(input, dummyToken, stack)\n      if (dummyToken.value > -1 && (!filter || filter(input.read(pos, dummyToken.end)))) return pos\n    }\n    return input.length\n  }\n}\n\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nexport class Parser {\n  /// @internal\n  maxNode: number\n  /// @internal\n  maxRepeatWrap: number\n  private nextStateCache: (readonly number[] | null)[] = []\n\n  /// @internal\n  constructor(\n    /// The parse states for this grammar @internal\n    readonly states: Readonly<Uint32Array>,\n    /// A blob of data that the parse states, as well as some\n    /// of `Parser`'s fields, point into @internal\n    readonly data: Readonly<Uint16Array>,\n    /// The goto table. See `computeGotoTable` in\n    /// lezer-generator for details on the format @internal\n    readonly goto: Readonly<Uint16Array>,\n    /// A node group with the node types used by this parser.\n    readonly group: NodeGroup,\n    /// The first repeat-related term id @internal\n    readonly minRepeatTerm: number,\n    /// The tokenizer objects used by the grammar @internal\n    readonly tokenizers: readonly Tokenizer[],\n    /// Maps top rule names to [state ID, top term ID] pairs.\n    readonly topRules: {[name: string]: [number, number]},\n    /// Metadata about nested grammars used in this grammar @internal\n    readonly nested: readonly {\n      /// A name, used by `withNested`\n      name: string,\n      /// The grammar or grammar query function to use\n      grammar: NestedGrammar,\n      /// A token-recognizing automaton for the end of the nesting\n      end: TokenGroup,\n      /// The id of the placeholder term that appears in the grammar at\n      /// the position of this nesting\n      placeholder: number\n    }[],\n    /// Points into this.data at an array of token types that\n    /// are specialized @internal\n    readonly specializeTable: number,\n    /// For each specialized token type, this holds an object mapping\n    /// names to numbers, with the first bit indicating whether the\n    /// specialization extends or replaces the original token, and the\n    /// rest of the bits holding the specialized token type. @internal\n    readonly specializations: readonly {[value: string]: number}[],\n    /// Points into this.data at an array that holds the\n    /// precedence order (higher precedence first) for ambiguous\n    /// tokens @internal\n    readonly tokenPrecTable: number,\n    /// An optional object mapping term ids to name strings @internal\n    readonly termNames: null | {[id: number]: string} = null\n  ) {\n    this.maxNode = this.group.types.length - 1\n    this.maxRepeatWrap = this.group.types.length + (this.group.types.length - minRepeatTerm) - 1\n    for (let i = 0, l = this.states.length / ParseState.Size; i < l; i++) this.nextStateCache[i] = null\n  }\n\n  /// Parse a given string or stream.\n  parse(input: InputStream | string, options?: ParseOptions) {\n    if (typeof input == \"string\") input = new StringStream(input)\n    let cx = new ParseContext(this, input, options)\n    for (;;) {\n      let done = cx.advance()\n      if (done) return done\n    }\n  }\n\n  /// Create a `ParseContext`.\n  startParse(input: InputStream | string, options?: ParseOptions) {\n    if (typeof input == \"string\") input = new StringStream(input)\n    return new ParseContext(this, input, options)\n  }\n\n  /// Get a goto table entry @internal\n  getGoto(state: number, term: number, loose = false) {\n    let table = this.goto\n    if (term >= table[0]) return -1\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++], last = groupTag & 1\n      let target = table[pos++]\n      if (last && loose) return target\n      for (let end = pos + (groupTag >> 1); pos < end; pos++)\n        if (table[pos] == state) return target\n      if (last) return -1\n    }\n  }\n\n  /// Check if this state has an action for a given terminal @internal\n  hasAction(state: number, terminal: number) {\n    let data = this.data\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? ParseState.Skip : ParseState.Actions), next; (next = data[i]) != Seq.End; i += 3) {\n        if (next == terminal || next == Term.Err)\n          return data[i + 1] | (data[i + 2] << 16)\n      }\n    }\n    return 0\n  }\n\n  /// @internal\n  stateSlot(state: number, slot: number) {\n    return this.states[(state * ParseState.Size) + slot]\n  }\n\n  /// @internal\n  stateFlag(state: number, flag: number) {\n    return (this.stateSlot(state, ParseState.Flags) & flag) > 0\n  }\n\n  /// @internal\n  startNested(state: number) {\n    let flags = this.stateSlot(state, ParseState.Flags)\n    return flags & StateFlag.StartNest ? flags >> StateFlag.NestShift : -1\n  }\n\n  /// @internal\n  validAction(state: number, action: number) {\n    if (action == this.stateSlot(state, ParseState.DefaultReduce)) return true\n    for (let i = this.stateSlot(state, ParseState.Actions);; i += 3) {\n      if (this.data[i] == Seq.End) return false\n      if (action == (this.data[i + 1] | (this.data[i + 2] << 16))) return true\n    }\n  }\n\n  /// Get the states that can follow this one through shift actions or\n  /// goto jumps. @internal\n  nextStates(state: number): readonly number[] {\n    let cached = this.nextStateCache[state]\n    if (cached) return cached\n    let result: number[] = []\n    for (let i = this.stateSlot(state, ParseState.Actions); this.data[i] != Seq.End; i += 3) {\n      if ((this.data[i + 2] & (Action.ReduceFlag >> 16)) == 0 && result.indexOf(this.data[i + 1]) < 0)\n        result.push(this.data[i + 1])\n    }\n    let table = this.goto, max = table[0]\n    for (let term = 0; term < max; term++) {\n      for (let pos = table[term + 1];;) {\n        let groupTag = table[pos++], target = table[pos++]\n        for (let end = pos + (groupTag >> 1); pos < end; pos++)\n          if (table[pos] == state && result.indexOf(target) < 0) result.push(target)\n        if (groupTag & 1) break\n      }\n    }\n    return this.nextStateCache[state] = result\n  }\n\n  /// @internal\n  overrides(token: number, prev: number) {\n    let iPrev = findOffset(this.data, this.tokenPrecTable, prev)\n    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev\n  }\n\n  /// Create a new `Parser` instance with different values for (some\n  /// of) the nested grammars. This can be used to, for example, swap\n  /// in a different language for a nested grammar or fill in a nested\n  /// grammar that was left blank by the original grammar.\n  withNested(spec: {[name: string]: NestedGrammar | null}) {\n    return new Parser(this.states, this.data, this.goto, this.group, this.minRepeatTerm, this.tokenizers, this.topRules,\n                      this.nested.map(obj => {\n                        if (!Object.prototype.hasOwnProperty.call(spec, obj.name)) return obj\n                        return {name: obj.name, grammar: spec[obj.name], end: obj.end, placeholder: obj.placeholder}\n                      }),\n                      this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames)\n  }\n\n  /// Create a new `Parser` instance whose node types have the given\n  /// props added. You should use [`NodeProp.add`](#tree.NodeProp.add)\n  /// to create the arguments to this method.\n  withProps(...props: NodePropSource[]) {\n    return new Parser(this.states, this.data, this.goto, this.group.extend(...props), this.minRepeatTerm,\n                      this.tokenizers, this.topRules, this.nested,\n                      this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames)\n  }\n\n  /// Returns the name associated with a given term. This will only\n  /// work for all terms when the parser was generated with the\n  /// `--names` option. By default, only the names of tagged terms are\n  /// stored.\n  getName(term: number): string {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.group.types[term].name || term)\n  }\n\n  /// The eof term id is always allocated directly after the node\n  /// types. @internal\n  get eofTerm() { return this.maxRepeatWrap + 1 }\n\n  /// Tells you whether this grammar has any nested grammars.\n  get hasNested() { return this.nested.length > 0 }\n\n  /// @internal\n  get defaultTop() { return this.topRules[Object.keys(this.topRules)[0]] }\n\n  /// The node type produced by the default top rule.\n  get topType() { return this.group.types[this.defaultTop[1]] }\n\n  /// (Used by the output of the parser generator) @internal\n  static deserialize(spec: {\n    states: string,\n    stateData: string,\n    goto: string,\n    nodeNames: string,\n    repeatNodeCount: number,\n    nodeProps?: [NodeProp<any>, ...(string | number)[]][],\n    tokenData: string,\n    tokenizers: (Tokenizer | number)[],\n    topRules: {[name: string]: [number, number]},\n    nested?: [string, null | NestedGrammar, string, number][],\n    specializeTable: number,\n    specializations?: readonly {[term: string]: number}[],\n    tokenPrec: number,\n    termNames?: {[id: number]: string}\n  }) {\n    let tokenArray = decodeArray(spec.tokenData)\n    let nodeNames = spec.nodeNames.split(\" \"), minRepeatTerm = nodeNames.length\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\")\n    let nodeProps: {[id: number]: any}[] = []\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push(noProps)\n    function setProp(nodeID: number, prop: NodeProp<any>, value: any) {\n      if (nodeProps[nodeID] == noProps) nodeProps[nodeID] = Object.create(null)\n      prop.set(nodeProps[nodeID], prop.deserialize(String(value)))\n    }\n    setProp(0, NodeProp.error, \"\")\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0]\n      for (let i = 1; i < propSpec.length; i += 2)\n        setProp(propSpec[i] as number, prop, propSpec[i + 1] as string)\n    }\n    let group = new NodeGroup(nodeNames.map((name, i) => new NodeType(name, nodeProps[i], i)))\n\n    return new Parser(decodeArray(spec.states, Uint32Array), decodeArray(spec.stateData),\n                      decodeArray(spec.goto), group, minRepeatTerm,\n                      spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value),\n                      spec.topRules,\n                      (spec.nested || []).map(([name, grammar, endToken, placeholder]) =>\n                                              ({name, grammar, end: new TokenGroup(decodeArray(endToken), 0), placeholder})),\n                      spec.specializeTable, (spec.specializations || []).map(withoutPrototype),\n                      spec.tokenPrec, spec.termNames)\n  }\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\nfunction findOffset(data: Readonly<Uint16Array>, start: number, term: number) {\n  for (let i = start, next; (next = data[i]) != Seq.End; i++)\n    if (next == term) return i - start\n  return -1\n}\n\n// Strip the prototypes from objects, so that they can safely be\n// accessed as maps.\nfunction withoutPrototype(obj: {}) {\n  if (!(obj instanceof Object)) return obj\n  let result: {[key: string]: any} = Object.create(null)\n  for (let prop in obj) if (Object.prototype.hasOwnProperty.call(obj, prop)) result[prop] = (obj as any)[prop]\n  return result\n}\n\nfunction findFinished(stacks: Stack[]) {\n  let best: Stack | null = null\n  for (let stack of stacks) {\n    if (stack.pos == stack.cx.input.length &&\n        stack.cx.parser.stateFlag(stack.state, StateFlag.Accepting) &&\n        (!best || best.recovered > stack.recovered))\n      best = stack\n  }\n  return best\n}\n\nfunction finishNested(stack: Stack) {\n  if (stack.cx.wrapType == -2) return null // Another nested stack already finished\n  let parent = stack.cx.parent!, tree = stack.forceAll().toTree()\n  let parentParser = parent.cx.parser, info = parentParser.nested[parentParser.startNested(parent.state)]\n  tree = new Tree(tree.type, tree.children, tree.positions.map(p => p - parent!.pos), stack.pos - parent.pos)\n  if (stack.cx.wrapType > -1) tree = new Tree(parentParser.group.types[stack.cx.wrapType], [tree], [0], tree.length)\n  stack.cx.wrapType = -2\n  parent.useNode(tree, parentParser.getGoto(parent.state, info.placeholder, true))\n  if (verbose) console.log(parent + ` (via unnest ${stack.cx.wrapType > -1 ? parentParser.getName(stack.cx.wrapType) : tree.type.name})`)\n  return parent\n}\n"],"names":[],"mappings":"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"}