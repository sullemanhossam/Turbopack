import { Text } from "./text";
export declare enum Section {
    Keep = 0,
    Delete = 1,
    Insert = 2
}
export declare enum MapMode {
    Simple = 0,
    TrackDel = 1,
    TrackBefore = 2,
    TrackAfter = 3
}
export declare type ChangeSpec = {
    insert: readonly string[];
    at: number;
} | {
    delete: number;
    to: number;
};
export declare class ChangeDesc {
    readonly sections: readonly number[];
    constructor(sections: readonly number[]);
    get length(): number;
    get newLength(): number;
    get empty(): boolean;
    iter(f: (type: Section, fromA: number, toA: number, fromB: number, toB: number, inserted: readonly string[] | null) => void): void;
    gaps(f: (posA: number, posB: number, length: number) => void): void;
    invertedDesc(): ChangeDesc;
    composeDesc(other: ChangeDesc): ChangeDesc;
    combineDesc(other: ChangeDesc): ChangeDesc;
    mapDesc(other: ChangeDesc | ChangeSet, before?: boolean): ChangeDesc;
    mapPos(pos: number, assoc?: number, mode?: MapMode): number;
    touchesRange(from: number, to: number): boolean | "cover";
    toString(): string;
    static make(sections: readonly [Section, number][]): ChangeDesc;
}
export declare class ChangeSet extends ChangeDesc {
    readonly inserted: readonly (readonly string[] | null)[];
    constructor(sections: readonly number[], inserted: readonly (readonly string[] | null)[]);
    apply(doc: Text): Text;
    invert(doc: Text): ChangeSet;
    compose(other: ChangeSet): ChangeSet;
    combine(other: ChangeSet): ChangeSet;
    map(other: ChangeSet | ChangeDesc, before?: boolean): ChangeSet;
    get desc(): ChangeDesc;
    static of(length: number, changes: readonly ChangeSpec[]): ChangeSet;
}
//# sourceMappingURL=change.d.ts.map