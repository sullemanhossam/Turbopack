{"version":3,"file":"index.js","sources":["../src/indent.js","../src/fold.js","../src/syntax.js"],"sourcesContent":["import { NodeProp } from \"lezer-tree\";\nimport { EditorState, IndentContext } from \"@codemirror/next/state\";\n/// A syntax tree node prop used to associate indentation strategies\n/// with node types. Such a strategy is a function from an indentation\n/// context to a number. That number may be -1, to indicate that no\n/// definitive indentation can be determined, or a column number to\n/// which the given line should be indented.\nexport const indentNodeProp = new NodeProp();\nexport function syntaxIndentation(syntax) {\n    return EditorState.indentation.of((cx, pos) => {\n        return computeIndentation(cx, syntax.getTree(cx.state), pos);\n    });\n}\n// Compute the indentation for a given position from the syntax tree.\nfunction computeIndentation(cx, ast, pos) {\n    let tree = ast.resolve(pos);\n    // Enter previous nodes that end in empty error terms, which means\n    // they were broken off by error recovery, so that indentation\n    // works even if the constructs haven't been finished.\n    for (let scan = tree, scanPos = pos;;) {\n        let last = scan.childBefore(scanPos);\n        if (!last)\n            break;\n        if (last.type.prop(NodeProp.error) && last.start == last.end) {\n            tree = scan;\n            scanPos = last.start;\n        }\n        else {\n            scan = last;\n            scanPos = scan.end + 1;\n        }\n    }\n    for (; tree; tree = tree.parent) {\n        let strategy = indentStrategy(tree);\n        if (strategy)\n            return strategy(new TreeIndentContext(cx, pos, tree));\n    }\n    return -1;\n}\nfunction indentStrategy(tree) {\n    let strategy = tree.type.prop(indentNodeProp);\n    if (strategy)\n        return strategy;\n    let first = tree.firstChild, close;\n    if (first && (close = first.type.prop(NodeProp.closedBy))) {\n        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;\n        return cx => delimitedStrategy(cx, true, 1, undefined, closed ? last.start : undefined);\n    }\n    return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() { return 0; }\n/// Objects of this type provide context information and helper\n/// methods to indentation functions.\nexport class TreeIndentContext extends IndentContext {\n    /// @internal\n    constructor(base, \n    /// The position at which indentation is being computed.\n    pos, \n    /// The syntax tree node for which the indentation strategy is\n    /// registered.\n    node) {\n        super(base.state, base.overrideIndentation, base.simulateBreak);\n        this.pos = pos;\n        this.node = node;\n    }\n    /// Get the text directly after `this.pos`, either the entire line\n    /// or the next 100 characters, whichever is shorter.\n    get textAfter() {\n        return this.textAfterPos(this.pos);\n    }\n    /// Get the indentation at the reference line for `this.node`, which\n    /// is the line on which it starts, unless there is a node that is\n    /// _not_ a parent of this node covering the start of that line. If\n    /// so, the line at the start of that node is tried, again skipping\n    /// on if it is covered by another such node.\n    get baseIndent() {\n        let line = this.state.doc.lineAt(this.node.start);\n        // Skip line starts that are covered by a sibling (or cousin, etc)\n        for (;;) {\n            let atBreak = this.node.resolve(line.from);\n            while (atBreak.parent && atBreak.parent.start == atBreak.start)\n                atBreak = atBreak.parent;\n            if (isParent(atBreak, this.node))\n                break;\n            line = this.state.doc.lineAt(atBreak.start);\n        }\n        return this.lineIndent(line);\n    }\n}\nfunction isParent(parent, of) {\n    for (let cur = of; cur; cur = cur.parent)\n        if (parent == cur)\n            return true;\n    return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n    let tree = context.node;\n    let openToken = tree.childAfter(tree.start), last = tree.lastChild;\n    if (!openToken || context.simulateBreak == openToken.end)\n        return null;\n    let openLine = context.state.doc.lineAt(openToken.start);\n    for (let pos = openToken.end;;) {\n        let next = tree.childAfter(pos);\n        if (!next || next == last)\n            return null;\n        if (!next.type.prop(NodeProp.skipped))\n            return next.start < openLine.to ? openToken : null;\n        pos = next.end;\n    }\n}\n/// An indentation strategy for delimited (usually bracketed) nodes.\n/// Will, by default, indent one unit more than the parent's base\n/// indent unless the line starts with a closing token. When `align`\n/// is true and there are non-skipped nodes on the node's opening\n/// line, the content of the node will be aligned with the end of the\n/// opening node, like this:\n///\n///     foo(bar,\n///         baz)\nexport function delimitedIndent({ closing, align = true, units = 1 }) {\n    return (context) => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n    let after = context.textAfter, space = after.match(/^\\s*/)[0].length;\n    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n    let aligned = align ? bracketedAligned(context) : null;\n    if (aligned)\n        return closed ? context.column(aligned.start) : context.column(aligned.end);\n    return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/// An indentation strategy that aligns a node content to its base\n/// indentation.\nexport const flatIndent = (context) => context.baseIndent;\n/// Creates an indentation strategy that, by default, indents\n/// continued lines one unit more than the node's base indentation.\n/// You can provide `except` to prevent indentation of lines that\n/// match a pattern (for example `/^else\\b/` in `if`/`else`\n/// constructs), and you can change the amount of units used with the\n/// `units` option.\nexport function continuedIndent({ except, units = 1 } = {}) {\n    return (context) => {\n        let matchExcept = except && except.test(context.textAfter);\n        return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n    };\n}\n","import { NodeProp } from \"lezer-tree\";\nimport { EditorState } from \"@codemirror/next/state\";\n/// This node prop is used to associate folding information with node\n/// types. Given a subtree, it should check whether that tree is\n/// foldable and return the range that can be collapsed when it is.\nexport const foldNodeProp = new NodeProp();\nexport function syntaxFolding(syntax) {\n    return EditorState.foldable.of((state, start, end) => {\n        let inner = syntax.getTree(state).resolve(end);\n        let found = null;\n        for (let cur = inner; cur; cur = cur.parent) {\n            if (cur.end <= end || cur.start > end)\n                continue;\n            if (found && cur.start < start)\n                break;\n            let prop = cur.type.prop(foldNodeProp);\n            if (prop) {\n                let value = prop(cur, state);\n                if (value && value.from <= end && value.from >= start && value.to > end)\n                    found = value;\n            }\n        }\n        return found;\n    });\n}\n","import { Tree } from \"lezer-tree\";\nimport { EditorState, StateField, StateEffect, Facet, languageDataProp } from \"@codemirror/next/state\";\nimport { ViewPlugin } from \"@codemirror/next/view\";\nimport { syntaxIndentation } from \"./indent\";\nimport { syntaxFolding } from \"./fold\";\n/// A [syntax provider](#state.Syntax) based on a\n/// [Lezer](https://lezer.codemirror.net) parser.\nexport class LezerSyntax {\n    /// Create a syntax instance for the given parser. You'll usually\n    /// want to use the\n    /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)\n    /// method to register CodeMirror-specific syntax node props in the\n    /// parser, before passing it to this constructor.\n    ///\n    /// When [language data](#state.EditorState.languageDataAt) is\n    /// given, it will be included in the syntax object's extension.\n    constructor(parser, config = {}) {\n        let setSyntax = StateEffect.define();\n        let { languageData } = config;\n        this.languageData = Facet.define({\n            combine: languageData ? values => values.concat(languageData) : undefined\n        });\n        parser = this.parser = parser.withProps(languageDataProp.add({ [parser.topType.name]: this.languageData }));\n        this.field = StateField.define({\n            create(state) { return SyntaxState.advance(Tree.empty, parser, state.doc); },\n            update(value, tr) { return value.apply(tr, parser, setSyntax); }\n        });\n        this.extension = [\n            EditorState.syntax.of(this),\n            this.field,\n            ViewPlugin.define(view => new HighlightWorker(view, this, setSyntax)),\n            syntaxIndentation(this),\n            syntaxFolding(this)\n        ];\n    }\n    getTree(state) {\n        return state.field(this.field).tree;\n    }\n    parsePos(state) {\n        return state.field(this.field).upto;\n    }\n    ensureTree(state, upto, timeout = 100) {\n        let field = state.field(this.field);\n        if (field.upto >= upto)\n            return field.updatedTree;\n        if (!field.parse)\n            field.startParse(this.parser, state.doc);\n        if (field.parse.pos < upto) {\n            let done = work(field.parse, timeout, upto);\n            if (done)\n                return field.stopParse(done, state.doc.length);\n        }\n        return field.parse.pos < upto ? null : field.stopParse();\n    }\n    languageDataFacetAt(state, pos) {\n        if (this.parser.hasNested) {\n            let tree = this.getTree(state);\n            let target = tree.resolve(pos);\n            while (target) {\n                let facet = target.type.prop(languageDataProp);\n                if (facet)\n                    return facet;\n                target = target.parent;\n            }\n        }\n        return this.languageData;\n    }\n}\nclass DocStream {\n    constructor(doc, length = doc.length) {\n        this.doc = doc;\n        this.length = length;\n        this.cursorPos = 0;\n        this.string = \"\";\n        this.cursor = doc.iter();\n    }\n    get(pos) {\n        if (pos >= this.length)\n            return -1;\n        let stringStart = this.cursorPos - this.string.length;\n        if (pos < stringStart || pos >= this.cursorPos) {\n            if (pos < this.cursorPos) { // Reset the cursor if we have to go back\n                this.cursor = this.doc.iter();\n                this.cursorPos = 0;\n            }\n            this.string = this.cursor.next(pos - this.cursorPos).value;\n            this.cursorPos = pos + this.string.length;\n            stringStart = this.cursorPos - this.string.length;\n        }\n        return this.string.charCodeAt(pos - stringStart);\n    }\n    read(from, to) {\n        let stringStart = this.cursorPos - this.string.length;\n        if (from < stringStart || to >= this.cursorPos)\n            return this.doc.sliceString(from, to);\n        else\n            return this.string.slice(from - stringStart, to - stringStart);\n    }\n    clip(at) {\n        return new DocStream(this.doc, at);\n    }\n}\nfunction work(parse, time, upto = 5000000 /* MaxPos */) {\n    let endTime = Date.now() + time;\n    for (;;) {\n        let done = parse.advance();\n        if (done)\n            return done;\n        if (parse.pos > upto || Date.now() > endTime)\n            return null;\n    }\n}\nfunction takeTree(parse, base) {\n    let parsed = parse.forceFinish();\n    let cache = parsed.applyChanges([{ fromA: parse.pos, toA: parsed.length, fromB: parse.pos, toB: parsed.length }])\n        .append(base.applyChanges([{ fromA: 0, toA: parse.pos, fromB: 0, toB: parse.pos }]));\n    return { parsed, cache };\n}\nclass SyntaxState {\n    constructor(\n    // The current tree. Immutable, because directly accessible from\n    // the editor state.\n    tree, \n    // The point upto which the document has been parsed.\n    upto, \n    // The tree that can be used as cache for further incremental\n    // parsing. May differ from tree/updatedTree if a parse is broken\n    // off halfway—in that case, this one will have nodes that touch\n    // the break-off point dropped/decomposed so that they don't get\n    // incorrectly reused. The other properties will have those nodes,\n    // since they may be useful for code consuming the tree.\n    cache) {\n        this.tree = tree;\n        this.upto = upto;\n        this.cache = cache;\n        // In-progress parse, if any\n        this.parse = null;\n        this.updatedTree = tree;\n    }\n    static advance(cache, parser, doc) {\n        let parse = parser.startParse(new DocStream(doc), { cache });\n        let done = work(parse, 25 /* Apply */);\n        if (done)\n            return new SyntaxState(done, doc.length, done);\n        let result = takeTree(parse, cache);\n        return new SyntaxState(result.parsed, parse.pos, result.cache);\n    }\n    apply(tr, parser, effect) {\n        for (let e of tr.effects)\n            if (e.is(effect))\n                return e.value;\n        if (!tr.docChanged)\n            return this;\n        let ranges = [];\n        tr.changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));\n        return SyntaxState.advance((this.parse ? takeTree(this.parse, this.updatedTree).cache : this.cache).applyChanges(ranges), parser, tr.state.doc);\n    }\n    startParse(parser, doc) {\n        this.parse = parser.startParse(new DocStream(doc), { cache: this.cache });\n    }\n    stopParse(tree, upto) {\n        if (!tree)\n            ({ parsed: tree, cache: this.cache } = takeTree(this.parse, this.updatedTree));\n        else\n            this.cache = tree;\n        this.updatedTree = tree;\n        this.upto = upto !== null && upto !== void 0 ? upto : this.parse.pos;\n        this.parse = null;\n        return tree;\n    }\n}\nlet requestIdle = typeof window != \"undefined\" && window.requestIdleCallback ||\n    ((callback, { timeout }) => setTimeout(callback, timeout));\nlet cancelIdle = typeof window != \"undefined\" && window.cancelIdleCallback || clearTimeout;\n// FIXME figure out some way to back off from full re-parses when the\n// document is large—you could waste a lot of battery re-parsing a\n// multi-megabyte document every time you insert a backtick, even if\n// it happens in the background.\nclass HighlightWorker {\n    constructor(view, syntax, setSyntax) {\n        this.view = view;\n        this.syntax = syntax;\n        this.setSyntax = setSyntax;\n        this.working = -1;\n        this.work = this.work.bind(this);\n        this.scheduleWork();\n    }\n    update(update) {\n        if (update.docChanged)\n            this.scheduleWork();\n    }\n    scheduleWork() {\n        if (this.working > -1)\n            return;\n        let { state } = this.view, field = state.field(this.syntax.field);\n        if (field.upto >= state.doc.length)\n            return;\n        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });\n    }\n    work(deadline) {\n        this.working = -1;\n        let { state } = this.view, field = state.field(this.syntax.field);\n        if (field.upto >= state.doc.length)\n            return;\n        if (!field.parse)\n            field.startParse(this.syntax.parser, state.doc);\n        let done = work(field.parse, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);\n        if (done || field.parse.badness > .8) {\n            let tree = field.stopParse(done, state.doc.length);\n            this.view.dispatch({\n                effects: this.setSyntax.of(new SyntaxState(tree, state.doc.length, field.cache))\n            });\n        }\n        else {\n            this.scheduleWork();\n        }\n    }\n    destroy() {\n        if (this.working >= 0)\n            cancelIdle(this.working);\n    }\n}\n"],"names":[],"mappings":"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"}