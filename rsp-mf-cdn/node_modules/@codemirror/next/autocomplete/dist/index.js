import { EditorView, Decoration, themeClass, keymap, WidgetType, ViewPlugin, logException } from '@codemirror/next/view';
import { StateEffect, StateField, Text, EditorSelection, precedence, EditorState, Facet, combineConfig, Transaction } from '@codemirror/next/state';
import { tooltips, showTooltip } from '@codemirror/next/tooltip';

const baseTheme = EditorView.baseTheme({
    "tooltip.autocomplete": {
        fontFamily: "monospace",
        overflowY: "auto",
        maxHeight: "10em",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
            cursor: "pointer",
            padding: "1px 1em 1px 3px",
            lineHeight: 1.2
        },
        "& > li[aria-selected]": {
            background_fallback: "#bdf",
            backgroundColor: "Highlight",
            color_fallback: "white",
            color: "HighlightText"
        }
    },
    "snippetField@light": { backgroundColor: "#ddd" },
    "snippetField@dark": { backgroundColor: "#333" },
    "snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    }
});

class FieldPos {
    constructor(field, line, from, to) {
        this.field = field;
        this.line = line;
        this.from = from;
        this.to = to;
    }
}
class FieldRange {
    constructor(field, from, to) {
        this.field = field;
        this.from = from;
        this.to = to;
    }
    map(changes) {
        return new FieldRange(this.field, changes.mapPos(this.from, -1), changes.mapPos(this.to, 1));
    }
}
class Snippet {
    constructor(lines, fieldPositions) {
        this.lines = lines;
        this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
        let text = [], lineStart = [pos];
        let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.slice(0, Math.min(100, lineObj.length)))[0];
        for (let line of this.lines) {
            if (text.length) {
                let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
                for (let i = 0; i < tabs; i++)
                    indent += state.facet(EditorState.indentUnit);
                lineStart.push(pos + indent.length - tabs);
                line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
        }
        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
        return { text, ranges };
    }
    static parse(template) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template.split(/\r\n?|\n/)) {
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
                let seq = m[1] ? +m[1] : null, name = m[2] || m[3], found = -1;
                for (let i = 0; i < fields.length; i++) {
                    if (name ? fields[i].name == name : seq != null && fields[i].seq == seq)
                        found = i;
                }
                if (found < 0) {
                    let i = 0;
                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))
                        i++;
                    fields.splice(i, 0, { seq, name: name || null });
                    found = i;
                }
                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
            }
            lines.push(line);
        }
        return new Snippet(lines, positions);
    }
}
class FieldMarker extends WidgetType {
    toDOM() {
        let span = document.createElement("span");
        span.className = themeClass("snippetFieldPosition");
        return span;
    }
}
let fieldMarker = Decoration.widget({ widget: new FieldMarker(null) });
let fieldRange = Decoration.mark({ class: themeClass("snippetField") });
class ActiveSnippet {
    constructor(ranges, active) {
        this.ranges = ranges;
        this.active = active;
        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
        return new ActiveSnippet(this.ranges.map(r => r.map(changes)), this.active);
    }
    selectionInsideField(sel) {
        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
}
const setActive = StateEffect.define({
    map(value, changes) { return value && value.map(changes); }
});
const moveToField = StateEffect.define();
const snippetState = StateField.define({
    create() { return null; },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setActive))
                return effect.value;
            if (effect.is(moveToField) && value)
                return new ActiveSnippet(value.ranges, effect.value);
        }
        if (value && tr.docChanged)
            value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
            value = null;
        return value;
    },
    provide: [EditorView.decorations.from(val => val ? val.deco : Decoration.none)]
});
function fieldSelection(ranges, field) {
    return EditorSelection.create(ranges.filter(r => r.field == field).map(r => EditorSelection.range(r.from, r.to)));
}
/// Convert a snippet template to a function that can apply it.
/// Snippets are written using syntax like this:
///
///     "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"
///
/// Each `${}` placeholder (you may also use `#{}`) indicates a field
/// that the user can fill in. Its name, if any, will be the default
/// content for the field.
///
/// When the snippet is activated by calling the returned function,
/// the code is inserted at the given position. Newlines in the
/// template are indented by the indentation of the start line, plus
/// one [indent unit](#state.EditorState^indentUnit) per tab character
/// after the newline.
///
/// On activation, (all instances of) the first field are selected.
/// The user can move between fields with Tab and Shift-Tab as long as
/// the fields are active. Moving to the last field or moving the
/// cursor out of the current field deactivates the fields.
///
/// The order of fields defaults to textual order, but you can add
/// numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
/// a custom order.
function snippet(template) {
    let snippet = Snippet.parse(template);
    return (editor, range) => {
        let { text, ranges } = snippet.instantiate(editor.state, range.from);
        let spec = { changes: { from: range.from, to: range.to, insert: Text.of(text) } };
        if (ranges.length)
            spec.selection = fieldSelection(ranges, 0);
        if (ranges.length > 1) {
            spec.effects = setActive.of(new ActiveSnippet(ranges, 0));
            if (editor.state.field(snippetState, false) === undefined)
                spec.reconfigure = { append: [snippetState, snippetKeymap, baseTheme] };
        }
        editor.dispatch(editor.state.update(spec));
    };
}
function moveField(dir) {
    return ({ state, dispatch }) => {
        let active = state.field(snippetState, false);
        if (!active || dir < 0 && active.active == 0)
            return false;
        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
        dispatch(state.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next))
        }));
        return true;
    };
}
const clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active)
        return false;
    dispatch(state.update({ effects: setActive.of(null) }));
    return true;
};
const snippetKeymap = precedence(keymap([
    { key: "Tab", run: moveField(1), shift: moveField(-1) },
    { key: "Escape", run: clearSnippet }
]), "override");
/// Create a completion source from an array of snippet specs.
function completeSnippets(snippets) {
    let parsed = snippets.map(s => ({ label: s.name || s.keyword, apply: snippet(s.snippet) }));
    return (context) => {
        let token = context.tokenBefore();
        let isAlpha = /[\w\u00a1-\uffff]/.test(token.text);
        if (!isAlpha && !context.explicit)
            return null;
        let options = [];
        for (let i = 0; i < snippets.length; i++) {
            let candidate = snippets[i];
            if (!token.text || context.filter(candidate.keyword, token.text))
                options.push(parsed[i]);
        }
        return { from: token.from, to: context.pos, options, filterDownOn: /^[\w\u00a1-\uffff]+$/ };
    };
}

/// Denotes how to
/// [filter](#autocomplete.autocomplete^config.filterType)
/// completions.
var FilterType;
(function (FilterType) {
    /// Only show completions that start with the currently typed text.
    FilterType[FilterType["Start"] = 0] = "Start";
    /// Show completions that have the typed text anywhere in their
    /// content.
    FilterType[FilterType["Include"] = 1] = "Include";
    /// Show completions that include each character of the typed text,
    /// in order (so `gBCR` could complete to `getBoundingClientRect`).
    FilterType[FilterType["Fuzzy"] = 2] = "Fuzzy";
})(FilterType || (FilterType = {}));
class AutocompleteContext {
    /// @internal
    constructor(
    /// The editor state that the completion happens in.
    state, 
    /// The position at which the completion happens.
    pos, 
    /// Indicates whether completion was activated explicitly, or
    /// implicitly by typing. The usual way to respond to this is to
    /// only return completions when either there is part of a
    /// completable entity at the cursor, or explicit is true.
    explicit, 
    /// The configured completion filter. Ignoring this won't break
    /// anything, but supporting it is encouraged.
    filterType, 
    /// Indicates whether completion has been configured to be
    /// case-sensitive. Again, this should be taken as a hint, not a
    /// requirement.
    caseSensitive) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        this.filterType = filterType;
        this.caseSensitive = caseSensitive;
    }
    /// Filter a given completion string against the partial input in
    /// `text`. Will use `this.filterType`, returns `true` when the
    /// completion should be shown.
    filter(completion, text, caseSensitive = this.caseSensitive) {
        if (!caseSensitive) {
            completion = completion.toLowerCase();
            text = text.toLowerCase();
        }
        if (this.filterType == FilterType.Start)
            return completion.slice(0, text.length) == text;
        else if (this.filterType == FilterType.Include)
            return completion.indexOf(text) > -1;
        // Fuzzy
        for (let i = 0, j = 0; i < text.length; i++) {
            let found = completion.indexOf(text[i], j);
            if (found < 0)
                return false;
            j = found + 1;
        }
        return true;
    }
    /// Get the extent, content, and (if there is a token) type of the
    /// token before `this.pos`.
    tokenBefore() {
        let from = this.pos, type = null, text = "";
        let token = this.state.tree.resolve(this.pos, -1);
        if (!token.firstChild && token.start < this.pos) {
            from = token.start;
            type = token.type;
            text = this.state.sliceDoc(from, this.pos);
        }
        return { from, to: this.pos, text, type };
    }
}
function canRefilter(result, state, changes) {
    if (!result.filterDownOn)
        return false;
    let to = changes ? changes.mapPos(result.to) : result.to, pos = state.selection.primary.head;
    if (pos < to || pos > to + 20)
        return false;
    return pos == to || result.filterDownOn.test(state.sliceDoc(to, pos));
}
function refilter(result, context) {
    let text = context.state.sliceDoc(result.from, context.pos);
    return {
        from: result.from,
        to: context.pos,
        options: result.options.filter(opt => context.filter(opt.label, text)),
        filterDownOn: result.filterDownOn
    };
}
class CombinedResult {
    constructor(sources, results, options) {
        this.sources = sources;
        this.results = results;
        this.options = options;
    }
    static create(sources, results) {
        let options = [];
        for (let i = 0, result; i < results.length; i++)
            if (result = results[i]) {
                for (let option of result.options)
                    options.push({ completion: option, source: i });
            }
        return new CombinedResult(sources, results, options.sort(({ completion: { label: a } }, { completion: { label: b } }) => a < b ? -1 : a == b ? 0 : 1));
    }
    get from() { return this.results.reduce((m, r) => r ? Math.min(m, r.from) : m, 1e9); }
    get to() { return this.results.reduce((m, r) => r ? Math.max(m, r.to) : m, 0); }
    map(changes) {
        return new CombinedResult(this.sources, this.results.map(r => r && Object.assign(Object.assign({}, r), { from: changes.mapPos(r.from), to: changes.mapPos(r.to) })), this.options);
    }
    refilterAll(state) {
        let config = state.facet(autocompleteConfig), pos = state.selection.primary.head;
        let context = new AutocompleteContext(state, pos, false, config.filterType, config.caseSensitive);
        return CombinedResult.create(this.sources, this.results.map(r => r && refilter(r, context)));
    }
}
function retrieveCompletions(state, pending) {
    let config = state.facet(autocompleteConfig), pos = state.selection.primary.head;
    let sources = config.override ? [config.override] : state.languageDataAt("autocomplete", pos);
    let context = new AutocompleteContext(state, pos, pending.explicit, config.filterType, config.caseSensitive);
    return Promise.all(sources.map(source => {
        let prevIndex = pending.prev ? pending.prev.result.sources.indexOf(source) : -1;
        let prev = prevIndex < 0 ? null : pending.prev.result.results[prevIndex];
        return (prev && canRefilter(prev, state) && refilter(prev, context)) || source(context);
    })).then(results => CombinedResult.create(sources, results));
}
const autocompleteConfig = Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            activateOnTyping: true,
            override: null,
            filterType: FilterType.Start,
            caseSensitive: false
        });
    }
});
/// Returns an extension that enables autocompletion.
function autocomplete(config = {}) {
    return [
        activeCompletion,
        autocompleteConfig.of(config),
        autocompletePlugin,
        baseTheme,
        tooltips(),
        precedence(keymap([
            { key: "ArrowDown", run: moveCompletion("down") },
            { key: "ArrowUp", run: moveCompletion("up") },
            { key: "PageDown", run: moveCompletion("down", "page") },
            { key: "PageUp", run: moveCompletion("up", "page") },
            { key: "Enter", run: acceptCompletion }
        ]), "override")
    ];
}
function moveCompletion(dir, by) {
    return (view) => {
        let active = view.state.field(activeCompletion);
        if (!(active instanceof ActiveCompletion) || Date.now() - active.timeStamp < CompletionInteractMargin)
            return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = view.dom.querySelector(".cm-tooltip-autocomplete")))
            step = Math.max(2, Math.floor(tooltip.offsetHeight / tooltip.firstChild.offsetHeight));
        let selected = active.selected + step * (dir == "up" ? -1 : 1), { length } = active.result.options;
        if (selected < 0)
            selected = by == "page" ? 0 : length - 1;
        else if (selected >= length)
            selected = by == "page" ? length - 1 : 0;
        view.dispatch({ effects: selectCompletion.of(selected) });
        return true;
    };
}
const CompletionInteractMargin = 75;
function acceptCompletion(view) {
    let active = view.state.field(activeCompletion);
    if (!(active instanceof ActiveCompletion) || Date.now() - active.timeStamp < CompletionInteractMargin)
        return false;
    applyCompletion(view, active.result, active.selected);
    return true;
}
/// Explicitly start autocompletion.
const startCompletion = (view) => {
    let active = view.state.field(activeCompletion, false);
    if (active === undefined)
        return false;
    if (active instanceof ActiveCompletion || (active instanceof PendingCompletion && active.explicit))
        return false;
    view.dispatch({ effects: toggleCompletion.of(true) });
    return true;
};
function applyCompletion(view, combined, index) {
    let option = combined.options[index];
    let apply = option.completion.apply || option.completion.label;
    let result = combined.results[option.source];
    if (typeof apply == "string") {
        view.dispatch({
            changes: { from: result.from, to: result.to, insert: apply },
            selection: { anchor: result.from + apply.length }
        });
    }
    else {
        apply(view, result, option.completion);
    }
}
/// Close the currently active completion.
const closeCompletion = (view) => {
    let active = view.state.field(activeCompletion, false);
    if (active == null)
        return false;
    view.dispatch({ effects: toggleCompletion.of(false) });
    return true;
};
/// Basic keybindings for autocompletion.
///
///  - Ctrl-Space (Cmd-Space on macOS): [`startCompletion`](#autocomplete.startCompletion)
///  - Escape: [`closeCompletion`](#autocomplete.closeCompletion)
const autocompleteKeymap = [
    { key: "Mod-Space", run: startCompletion },
    { key: "Escape", run: closeCompletion }
];
const openCompletion = StateEffect.define();
const toggleCompletion = StateEffect.define();
const selectCompletion = StateEffect.define();
function touchesCompletion(tr, completion) {
    return completion instanceof ActiveCompletion ? tr.changes.touchesRange(completion.result.from, completion.result.to)
        : tr.changes.touchesRange(tr.state.selection.primary.head);
}
const activeCompletion = StateField.define({
    create() { return null; },
    update(value, tr) {
        let event = tr.annotation(Transaction.userEvent);
        if (event == "input" && value instanceof ActiveCompletion &&
            value.result.results.every(r => !r || canRefilter(r, tr.state, tr.changes))) {
            value = new ActiveCompletion(value.result.map(tr.changes).refilterAll(tr.state), 0, value.timeStamp);
        }
        else if (event == "input" && (value || tr.state.facet(autocompleteConfig).activateOnTyping) ||
            event == "delete" && value) {
            let prev = value instanceof ActiveCompletion ? value : value instanceof PendingCompletion ? value.prev : null;
            value = new PendingCompletion(prev, value instanceof PendingCompletion ? value.explicit : false);
        }
        else if (value && (tr.selection || tr.docChanged && touchesCompletion(tr, value))) {
            // Clear on selection changes or changes that touch the completion
            value = null;
        }
        else if (tr.docChanged && value instanceof ActiveCompletion) {
            value = new ActiveCompletion(value.result.map(tr.changes), value.selected, value.timeStamp);
        }
        for (let effect of tr.effects) {
            if (effect.is(openCompletion))
                value = new ActiveCompletion(effect.value, 0);
            else if (effect.is(toggleCompletion))
                value = effect.value ? new PendingCompletion(null, true) : null;
            else if (effect.is(selectCompletion) && value instanceof ActiveCompletion)
                value = new ActiveCompletion(value.result, effect.value, value.timeStamp, value.id, value.tooltip);
        }
        return value;
    },
    provide: [
        showTooltip.nFrom(active => active instanceof ActiveCompletion ? active.tooltip : none),
        EditorView.contentAttributes.from(active => active instanceof ActiveCompletion ? active.attrs : baseAttrs)
    ]
});
const baseAttrs = { "aria-autocomplete": "list" }, none = [];
class ActiveCompletion {
    constructor(result, selected, timeStamp = Date.now(), id = "cm-ac-" + Math.floor(Math.random() * 1679616).toString(36), tooltip = [{
            pos: result.from,
            style: "autocomplete",
            create: completionTooltip(result, id)
        }]) {
        this.result = result;
        this.selected = selected;
        this.timeStamp = timeStamp;
        this.id = id;
        this.tooltip = tooltip;
        this.attrs = {
            "aria-autocomplete": "list",
            "aria-activedescendant": this.id + "-" + this.selected,
            "aria-owns": this.id
        };
    }
}
class PendingCompletion {
    constructor(prev, explicit) {
        this.prev = prev;
        this.explicit = explicit;
    }
}
function createListBox(result, id) {
    const ul = document.createElement("ul");
    ul.id = id;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    for (let i = 0; i < result.options.length; i++) {
        const li = ul.appendChild(document.createElement("li"));
        li.id = id + "-" + i;
        li.innerText = result.options[i].completion.label;
        li.setAttribute("role", "option");
    }
    return ul;
}
// We allocate a new function instance every time the completion
// changes to force redrawing/repositioning of the tooltip
function completionTooltip(result, id) {
    return (view) => {
        let list = createListBox(result, id);
        list.addEventListener("click", (e) => {
            let index = 0, dom = e.target;
            for (;;) {
                dom = dom.previousSibling;
                if (!dom)
                    break;
                index++;
            }
            if (index < result.options.length)
                applyCompletion(view, result, index);
        });
        function updateSel(view) {
            let cur = view.state.field(activeCompletion);
            if (cur instanceof ActiveCompletion)
                updateSelectedOption(list, cur.selected);
        }
        return {
            dom: list,
            mount: updateSel,
            update(update) {
                if (update.state.field(activeCompletion) != update.prevState.field(activeCompletion))
                    updateSel(update.view);
            }
        };
    };
}
function updateSelectedOption(list, selected) {
    let set = null;
    for (let opt = list.firstChild, i = 0; opt; opt = opt.nextSibling, i++) {
        if (i == selected) {
            if (!opt.hasAttribute("aria-selected")) {
                opt.setAttribute("aria-selected", "true");
                set = opt;
            }
        }
        else {
            if (opt.hasAttribute("aria-selected"))
                opt.removeAttribute("aria-selected");
        }
    }
    if (set)
        scrollIntoView(list, set);
}
function scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    if (self.top < parent.top)
        container.scrollTop -= parent.top - self.top;
    else if (self.bottom > parent.bottom)
        container.scrollTop += self.bottom - parent.bottom;
}
const DebounceTime = 100;
const autocompletePlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.stateVersion = 0;
        this.debounce = -1;
    }
    update(update) {
        if (!update.docChanged && !update.selectionSet &&
            update.prevState.field(activeCompletion) == update.state.field(activeCompletion))
            return;
        if (update.docChanged || update.selectionSet)
            this.stateVersion++;
        if (this.debounce > -1)
            clearTimeout(this.debounce);
        const active = update.state.field(activeCompletion);
        this.debounce = active instanceof PendingCompletion
            ? setTimeout(() => this.startUpdate(active), DebounceTime) : -1;
    }
    startUpdate(pending) {
        this.debounce = -1;
        let { view, stateVersion } = this;
        retrieveCompletions(view.state, pending).then(result => {
            if (this.stateVersion != stateVersion || result.options.length == 0)
                return;
            view.dispatch({ effects: openCompletion.of(result) });
        }).catch(e => logException(view.state, e));
    }
});
/// Given a a fixed array of options, return an autocompleter that
/// compares those options to the current
/// [token](#autocomplete.AutocompleteContext.tokenBefore) and returns
/// the matching ones.
function completeFromList(list) {
    let options = list.map(o => typeof o == "string" ? { label: o } : o);
    let filterDownOn = options.every(o => /^\w+$/.test(o.label)) ? /^\w+$/ : undefined;
    return (context) => {
        let token = context.tokenBefore();
        return { from: token.from, to: token.to,
            options: options.filter(o => context.filter(o.label, token.text)),
            filterDownOn };
    };
}

export { AutocompleteContext, FilterType, autocomplete, autocompleteKeymap, closeCompletion, completeFromList, completeSnippets, snippet, startCompletion };
