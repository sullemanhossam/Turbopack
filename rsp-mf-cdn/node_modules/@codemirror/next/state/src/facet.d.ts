import { Transaction } from "./transaction";
import { EditorState } from "./state";
declare type FacetConfig<Input, Output> = {
    combine?: (value: readonly Input[]) => Output;
    compare?: (a: Output, b: Output) => boolean;
    compareInput?: (a: Input, b: Input) => boolean;
    static?: boolean;
};
export declare class Facet<Input, Output = readonly Input[]> {
    private isStatic;
    private constructor();
    static define<Input, Output = readonly Input[]>(config?: FacetConfig<Input, Output>): Facet<Input, Output>;
    of(value: Input): Extension;
    compute(deps: readonly Slot<any>[], get: (state: EditorState) => Input): Extension;
    computeN(deps: readonly Slot<any>[], get: (state: EditorState) => readonly Input[]): Extension;
    from<T>(get: (value: T) => Input, prec?: Precedence): (field: StateField<T>) => Extension;
    nFrom<T>(get: (value: T) => readonly Input[], prec?: Precedence): (field: StateField<T>) => Extension;
}
declare type Slot<T> = Facet<any, T> | StateField<T> | "doc" | "selection";
declare const isExtension: unique symbol;
declare type StateFieldSpec<Value> = {
    create: (state: EditorState) => Value;
    update: (value: Value, transaction: Transaction) => Value;
    compare?: (a: Value, b: Value) => boolean;
    provide?: readonly (Facet<Value, any> | ((field: StateField<Value>) => Extension))[];
};
export declare class StateField<Value> {
    private createF;
    private updateF;
    private compareF;
    private constructor();
    static define<Value>(config: StateFieldSpec<Value>): StateField<Value>;
    [isExtension]: true;
}
export declare type Extension = {
    [isExtension]: true;
} | {
    extension: Extension;
} | readonly Extension[];
export declare type Precedence = "fallback" | "default" | "extend" | "override";
export declare function precedence(extension: Extension, value: Precedence): PrecExtension;
declare class PrecExtension {
    readonly e: Extension;
    readonly prec: number;
    constructor(e: Extension, prec: number);
    [isExtension]: true;
}
declare class TaggedExtension {
    readonly tag: string | symbol;
    readonly extension: Extension;
    constructor(tag: string | symbol, extension: Extension);
    [isExtension]: true;
}
export declare function tagExtension(tag: string | symbol, extension: Extension): TaggedExtension;
export declare type ExtensionMap = {
    [tag: string]: Extension | undefined;
};
declare type DynamicSlot = (state: EditorState, tr: Transaction | null) => number;
export declare class Configuration {
    readonly source: Extension;
    readonly replacements: ExtensionMap;
    readonly dynamicSlots: DynamicSlot[];
    readonly address: {
        [id: number]: number;
    };
    readonly staticValues: readonly any[];
    readonly statusTemplate: SlotStatus[];
    constructor(source: Extension, replacements: ExtensionMap, dynamicSlots: DynamicSlot[], address: {
        [id: number]: number;
    }, staticValues: readonly any[]);
    staticFacet<Output>(facet: Facet<any, Output>): any;
    static resolve(extension: Extension, replacements?: ExtensionMap, oldState?: EditorState): Configuration;
}
export declare const enum SlotStatus {
    Uninitialized = 0,
    Changed = 1,
    Computed = 2,
    Computing = 4
}
export declare function ensureAddr(state: EditorState, addr: number): number;
export declare function getAddr(state: EditorState, addr: number): any;
export {};
//# sourceMappingURL=facet.d.ts.map