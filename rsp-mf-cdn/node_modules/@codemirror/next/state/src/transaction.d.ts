import { ChangeSet, ChangeDesc, ChangeSpec } from "./change";
import { EditorState } from "./state";
import { EditorSelection } from "./selection";
import { Extension } from "./facet";
export declare class Annotation<T> {
    readonly type: AnnotationType<T>;
    readonly value: T;
    static define<T>(): AnnotationType<T>;
}
export declare class AnnotationType<T> {
    of(value: T): Annotation<T>;
}
interface StateEffectSpec<Value> {
    map?: (value: Value, mapping: ChangeDesc) => Value | undefined;
}
export declare class StateEffect<Value> {
    readonly value: Value;
    map(mapping: ChangeDesc): StateEffect<Value> | undefined;
    is<T>(type: StateEffectType<T>): this is StateEffect<T>;
    static define<Value = null>(spec?: StateEffectSpec<Value>): StateEffectType<Value>;
    static mapEffects(effects: readonly StateEffect<any>[], mapping: ChangeDesc): readonly StateEffect<any>[];
}
export declare class StateEffectType<Value> {
    readonly map: (value: any, mapping: ChangeDesc) => any | undefined;
    of(value: Value): StateEffect<Value>;
}
export declare type TransactionSpec = {
    changes?: ChangeSpec;
    selection?: EditorSelection | {
        anchor: number;
        head?: number;
    };
    effects?: StateEffect<any> | readonly StateEffect<any>[];
    annotations?: Annotation<any> | readonly Annotation<any>[];
    scrollIntoView?: boolean;
    filter?: boolean;
    reconfigure?: ReconfigurationSpec;
};
export declare type ReconfigurationSpec = {
    full?: Extension;
    append?: Extension;
    [tag: string]: Extension | undefined;
};
export declare type StrictTransactionSpec = {
    changes: ChangeSet;
    selection: EditorSelection | undefined;
    effects: readonly StateEffect<any>[];
    annotations: readonly Annotation<any>[];
    scrollIntoView: boolean;
    filter: boolean;
    reconfigure: ReconfigurationSpec | undefined;
};
export declare const enum TransactionFlag {
    scrollIntoView = 1
}
export declare class Transaction {
    readonly startState: EditorState;
    readonly changes: ChangeSet;
    readonly selection: EditorSelection | undefined;
    readonly effects: readonly StateEffect<any>[];
    private annotations;
    readonly reconfigured: ReconfigurationSpec | undefined;
    private flags;
    readonly state: EditorState;
    annotation<T>(type: AnnotationType<T>): T | undefined;
    get docChanged(): boolean;
    get scrolledIntoView(): boolean;
    static time: AnnotationType<number>;
    static userEvent: AnnotationType<string>;
    static addToHistory: AnnotationType<boolean>;
}
export declare class ResolvedTransactionSpec implements StrictTransactionSpec {
    readonly changes: ChangeSet;
    readonly selection: EditorSelection | undefined;
    readonly effects: readonly StateEffect<any>[];
    readonly annotations: readonly Annotation<any>[];
    readonly scrollIntoView: boolean;
    readonly filter: boolean;
    readonly reconfigure: ReconfigurationSpec | undefined;
    constructor(changes: ChangeSet, selection: EditorSelection | undefined, effects: readonly StateEffect<any>[], annotations: readonly Annotation<any>[], scrollIntoView: boolean, filter: boolean, reconfigure: ReconfigurationSpec | undefined);
    static create(state: EditorState, specs: TransactionSpec | readonly TransactionSpec[]): ResolvedTransactionSpec;
    combine(b: ResolvedTransactionSpec): ResolvedTransactionSpec;
}
export {};
//# sourceMappingURL=transaction.d.ts.map