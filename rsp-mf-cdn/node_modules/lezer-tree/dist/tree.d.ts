export declare const DefaultBufferLength = 1024;
export interface ChangedRange {
    fromA: number;
    toA: number;
    fromB: number;
    toB: number;
}
declare type EnterFunc<T> = (type: NodeType, start: number, end: number) => T | false | undefined;
declare type LeaveFunc = (type: NodeType, start: number, end: number) => void;
declare type IterateArgs<T> = {
    enter: EnterFunc<T>;
    leave?: LeaveFunc;
    from?: number;
    to?: number;
};
declare class Iteration<T> {
    readonly enter: EnterFunc<T>;
    readonly leave: LeaveFunc | undefined;
    result: T | undefined;
    constructor(enter: EnterFunc<T>, leave: LeaveFunc | undefined);
    get done(): boolean;
    doEnter(type: NodeType, start: number, end: number): boolean;
}
export declare class NodeProp<T> {
    id: number;
    deserialize: (str: string) => T;
    constructor({ deserialize }?: {
        deserialize?: (str: string) => T;
    });
    static string(): NodeProp<string>;
    static number(): NodeProp<number>;
    static flag(): NodeProp<boolean>;
    set(propObj: {
        [prop: number]: any;
    }, value: T): {
        [prop: number]: any;
    };
    add(match: {
        [selector: string]: T;
    } | ((type: NodeType) => T | undefined)): NodePropSource;
    static error: NodeProp<boolean>;
    static skipped: NodeProp<boolean>;
    static closedBy: NodeProp<readonly string[]>;
    static openedBy: NodeProp<readonly string[]>;
    static top: NodeProp<boolean>;
}
export declare class NodePropSource {
    readonly prop: NodeProp<any>;
    readonly f: (type: NodeType) => any;
    constructor(prop: NodeProp<any>, f: (type: NodeType) => any);
}
export declare class NodeType {
    readonly name: string;
    readonly props: {
        readonly [prop: number]: any;
    };
    readonly id: number;
    constructor(name: string, props: {
        readonly [prop: number]: any;
    }, id: number);
    prop<T>(prop: NodeProp<T>): T | undefined;
    static none: NodeType;
    static match<T>(map: {
        [selector: string]: T;
    }): (node: NodeType) => T | undefined;
}
export declare class NodeGroup {
    readonly types: readonly NodeType[];
    constructor(types: readonly NodeType[]);
    extend(...props: NodePropSource[]): NodeGroup;
}
export declare abstract class Subtree {
    abstract parent: Subtree | null;
    abstract type: NodeType;
    get name(): string;
    abstract start: number;
    abstract end: number;
    get depth(): number;
    get root(): Tree;
    abstract toString(): string;
    abstract iterate<T = any>(args: IterateArgs<T>): T | undefined;
    resolve(pos: number, side?: -1 | 0 | 1): Subtree;
    abstract resolveAt(pos: number): Subtree;
    abstract childBefore(pos: number): Subtree | null;
    abstract childAfter(pos: number): Subtree | null;
    get firstChild(): Subtree | null;
    get lastChild(): Subtree | null;
}
export declare class Tree extends Subtree {
    readonly type: NodeType;
    readonly children: readonly (Tree | TreeBuffer)[];
    readonly positions: readonly number[];
    readonly length: number;
    parent: null;
    constructor(type: NodeType, children: readonly (Tree | TreeBuffer)[], positions: readonly number[], length: number);
    get start(): number;
    get end(): number;
    toString(): string;
    private partial;
    applyChanges(changes: readonly ChangedRange[]): Tree;
    cut(at: number): Tree;
    static empty: Tree;
    iterate<T = any>({ from, to, enter, leave }: IterateArgs<T>): T | undefined;
    iterInner<T>(from: number, to: number, offset: number, iter: Iteration<T>): void;
    resolveAt(pos: number): Subtree;
    childBefore(pos: number): Subtree | null;
    childAfter(pos: number): Subtree | null;
    findChild(pos: number, side: number, start: number, parent: Subtree): Subtree | null;
    resolveInner(pos: number, start: number, parent: Subtree): Subtree;
    append(other: Tree): Tree;
    balance(maxBufferLength?: number): Tree;
    static build(data: BuildData): Tree;
}
export declare type BuildData = {
    buffer: BufferCursor | readonly number[];
    group: NodeGroup;
    topID?: number;
    maxBufferLength?: number;
    reused?: (Tree | TreeBuffer)[];
    minRepeatType?: number;
};
export declare class TreeBuffer {
    readonly buffer: Uint16Array;
    readonly length: number;
    readonly group: NodeGroup;
    readonly type: NodeType;
    constructor(buffer: Uint16Array, length: number, group: NodeGroup, type?: NodeType);
    toString(): string;
    childToString(index: number, parts: string[]): number;
    cut(at: number): TreeBuffer;
    iterate<T = any>({ from, to, enter, leave }: IterateArgs<T>): T | undefined;
    iterInner<T>(from: number, to: number, offset: number, iter: Iteration<T>): void;
    iterChild<T>(from: number, to: number, offset: number, index: number, iter: Iteration<T>): number;
    private parentNodesByEnd;
    iterRev<T>(from: number, to: number, offset: number, startIndex: number, endIndex: number, iter: Iteration<T>): void;
    findIndex(pos: number, side: number, start: number, from: number, to: number): number;
}
export interface BufferCursor {
    pos: number;
    id: number;
    start: number;
    end: number;
    size: number;
    next(): void;
    fork(): BufferCursor;
}
export {};
