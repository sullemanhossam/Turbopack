'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezer = require('lezer');

// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  StartTag = 1,
  StartCloseTag = 2,
  MismatchedStartCloseTag = 3,
  missingCloseTag = 38,
  SelfCloseEndTag = 4,
  Element = 9,
  OpenTag = 10,
  SelfClosingTag = 20,
  RawText = 24;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33;

const tagStartExpr = /^<\s*([\.\-\:\w\xa1-\uffff]+)/;

const elementQuery = [Element];

const tagStart = new lezer.ExternalTokenizer((input, token, stack) => {
  let pos = token.start, first = input.get(pos);
  // End of file, just close anything
  if (first < 0) {
    let contextStart = stack.startOf(elementQuery);
    let match = contextStart < 0 ? null : tagStartExpr.exec(input.read(contextStart, contextStart + 30));
    if (match && implicitlyClosed[match[1].toLowerCase()]) token.accept(missingCloseTag, token.start);
  }
  if (first != lessThan) return
  pos++;
  let close = false, tokEnd = pos;
  for (let next; next = input.get(pos);) {
    if (next == slash && !close) { close = true; pos++; tokEnd = pos; }
    else if (next == question || next == bang) return
    else if (isSpace(next)) pos++;
    else break
  }
  let nameStart = pos;
  while (nameChar(input.get(pos))) pos++;
  if (pos > nameStart) {
    let name = input.read(nameStart, pos).toLowerCase();
    let contextStart = stack.startOf(elementQuery);
    let match = contextStart < 0 ? null : tagStartExpr.exec(input.read(contextStart, contextStart + name.length + 10));
    if (match) {
      let contextName = match[1].toLowerCase();
      if (close && name != contextName)
        return implicitlyClosed[contextName] ? token.accept(missingCloseTag, token.start)
          : token.accept(MismatchedStartCloseTag, tokEnd)
      if (!close && closeOnOpen[contextName] && closeOnOpen[contextName][name])
        return token.accept(missingCloseTag, token.start)
    }
  }
  token.accept(close ? StartCloseTag : StartTag, tokEnd);
}, {contextual: true});

const tagQuery = [OpenTag, SelfClosingTag];

const selfClosed = new lezer.ExternalTokenizer((input, token, stack) => {
  let next = input.get(token.start), end = token.start + 1;
  if (next == slash) {
    if (input.get(end) != greaterThan) return
    end++;
  } else if (next != greaterThan) {
    return
  }
  let from = stack.startOf(tagQuery);
  let match = from < 0 ? null : tagStartExpr.exec(input.read(from, token.start));
  if (match && selfClosers[match[1].toLowerCase()]) token.accept(SelfCloseEndTag, end);
}, {contextual: true});

const openTag = /^<\/?\s*([\.\-\:\w\xa1-\uffff]+)/;

function tagName(tag) {
  let m = openTag.exec(tag);
  return m ? m[1].toLowerCase() : null
}

function attributes(tag) {
  let open = openTag.exec(tag), attrs = {};
  if (open) {
    let attr = /\s*([\.\-\:\w\xa1-\uffff]+)\s*(?:=("[^"]*"|'[^']*'|[^\s=<>"'/]+))?/g, m;
    attr.lastIndex = open.index + open[0].length;
    while (m = attr.exec(tag)) attrs[m[1]] = m[2] || m[1];
  }
  return attrs
}

const stay = {stay: true};

function skip(name) { return token => tagName(token) == name }

// tags: {
//   tag: string,
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser?: Parser,
//   parseNode?: (input: InputStream, start: number) => Tree
// }[]

function resolveContent(tags) {
  let tagMap = null;
  for (let tag of tags) {
    if (!tagMap) tagMap = Object.create(null)
    ;(tagMap[tag.tag] || (tagMap[tag.tag] = [])).push({
      attrs: tag.attrs,
      value: {
        filterEnd: skip(tag.tag),
        parser: tag.parser,
        parseNode: tag.parseNode
      }
    });
  }
  return function(input, stack) {
    let openTag = input.read(stack.ruleStart, stack.pos);
    let name = tagName(openTag), matches, attrs;
    if (!name) return stay
    if (tagMap && (matches = tagMap[name])) {
      for (let match of matches) {
        if (!match.attrs || match.attrs(attrs || (attrs = attributes(openTag)))) return match.value
      }
    }
    if (name == "script" || name == "textarea" || name == "style") return {
      filterEnd: skip(name),
      wrapType: RawText
    }
    return stay
  }
}

const elementContent = resolveContent([]);

function configureTags(parser, tags) {
  return parser.withNested({elementContent: resolveContent(tags)})
}

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = lezer.Parser.deserialize({
  states: "(QOPOTOOOgOTO'#C{O!QOWO'#CfS!XOTO'#CeOOOO'#Ce'#CeOOOO'#DT'#DTOOOO(3AX(3AXQOOOOOOOOO,59a,59aO!uOWO'#C|OOOO(3AY(3AYO#POWO,59QO#TOTO'#DQOOOO(3A^(3A^OOOO'#DZ'#DZO#qOPO,59POOOO,59b,59bO#{ObO1G.lOOOO,59f,59fO!QOWO'#CnO$YOpO'#CnOOOO1G.k1G.kO$aObO'#C|O$qObO7+$WO${OWO,59YO%POpO'#C|O%WOpO,59YO%[ObO'#C}O%fObO'#ChOOOO(3AZ(3AZO%vOYO<<GrO%}OWO1G.tOOOO,59c,59cO&UObO,59SOOOOAN=^AN=^OOOOAN=hAN=hO&cOWO7+$`O&gO!bO1G.nOOOO<<Gz<<GzO&tO!bO'#C|O'RO!bO7+$YO']O#tO'#CkO'jO&jO'#CkO#{ObO<<GtO'wO#tO'#DOOOOO(3A[(3A[O(UOWO,59VO(YO&jO'#DPOOOO(3A](3A]O(gOWO,59VOOOOAN=`AN=`OOOO,59d,59dOOOO1G.q1G.qOOOO,59e,59e",
  stateData: "(o~PQOUTOVTOWTOeTOfTOgUO~PQOUTOVTOWTOeTOfTOgUOuoX~xYOZpP~PQOUTOVTOWTOeTOfTOQtPRtPvtP~xYOZpXapX~ZaO~PQOUTOVTOWTOeTOfTOQtXRtXvtX~QcORdOveO~xYOSpP]pPapP~xYOcpP~xYOSpX]pXapX^pX~]lOSqPaqP~ZoO~xYOcpX~coO~]lOSqXaqX~xYOSpP]pP^pPapP~SsOarO~xYOapP~^uOS[a][aa[a~avO~xYO`pPypP{pP~xYO`pXypX{pX~`{OyyO{zO~V}OW}Oz}OyrP~V!QOW!QO|!QO{sP~V}OW}Oz}OyrX~y!UO~V!QOW!QO|!QO{sX~{!UO~efg~",
  goto: "$w!OPPPPPPPPP!P!VP!]PP!aPP!dP!gPPPP!m!s#Z#a#g#m#s#v$`$c$f$iPP$lPPPPP$tXTOPR[XROPR[TmgkR{xRe_XSOPR[QPORWPUXQcoW`XfiwUfal{QidRwuQkgRpkQ|yR!T|Q!PzR!V!PQ[RRb[RVOQZQQgaQhcQjdQqlQtoQxuR!S{RngR!OyR!RzR^RSUOPT]R[R_R",
  nodeNames: "âš  StartTag StartCloseTag StartCloseTag SelfCloseEndTag Document Text EntityReference CharacterReference Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag CloseTag MismatchedTagName SelfClosingTag Comment ProcessingInst DoctypeDecl RawText",
  nodeProps: [
    [lezer.NodeProp.closedBy, 1,"EndTag SelfCloseEndTag",2,"EndTag SelfCloseEndTag",10,"CloseTag"],
    [lezer.NodeProp.openedBy, 4,"StartTag",17,"StartTag StartCloseTag",18,"OpenTag"],
    [lezer.NodeProp.top, 5,true]
  ],
  repeatNodeCount: 6,
  tokenData: "!(S#sR!UOX$eXY)mYZ)mZ]$e]^)m^p$epq)mqr$ers*tsv$evw+^wx2qx!P$e!P!Q3^!Q![$e![!]4t!]!^$e!^!_:c!_!`!%t!`!a4S!a!c$e!c!}4t!}#R$e#R#S4t#S#T$e#T#o4t#o$f$e$f$g%{$g%W$e%W%o4t%o%p$e%p&a4t&a&b$e&b1p4t1p4U$e4U4d4t4d4e$e4e$IS4t$IS$I`$e$I`$Ib4t$Ib$Kh$e$Kh%#t4t%#t&/x$e&/x&Et4t&Et&FV$e&FV;'S4t;'S;:j!&f;:j?&r$e?&r?Ah4t?Ah?BY$e?BY?Mn4t?Mn~$e#e$pcUP``zp|!bOX$eXZ%{Z]$e]^%{^p$epq%{qr$ers&ksv$evw({wx'lx!P$e!P!Q%{!Q!^$e!^!_(e!_!a%{!a$f$e$f$g%{$g~$e#T&UVUPzp|!bOr%{rs&ksv%{wx'lx!^%{!^!_(e!_~%{!c&rTUP|!bOv&kwx'Rx!^&k!^!_'a!_~&kP'WRUPOv'Rw!^'R!_~'R!b'fQ|!bOv'ax~'aq'sUUPzpOr'lrs'Rsv'lw!^'l!^!_(V!_~'lp([RzpOr(Vsv(Vw~(V#S(lTzp|!bOr(ers'asv(ewx(Vx~(e`)QX``OX({Z]({^p({qr({sw({x!P({!Q!^({!a$f({$g~({#s)x^UPzp|!bxnOX%{XY)mYZ)mZ]%{]^)m^p%{pq)mqr%{rs&ksv%{wx'lx!^%{!^!_(e!_~%{#g*}Ty!SUP|!bOv&kwx'Rx!^&k!^!_'a!_~&k#e+cb``OX,kXZ-xZ],k]^-x^p,kqr,krs-xst/Ttw,kwx-xx!P,k!P!Q-x!Q!],k!]!^({!^!a-x!a$f,k$f$g-x$g~,k#e,pb``OX,kXZ-xZ],k]^-x^p,kqr,krs-xst({tw,kwx-xx!P,k!P!Q-x!Q!],k!]!^.a!^!a-x!a$f,k$f$g-x$g~,k#T-{TOp-xqs-xt!]-x!]!^.[!^~-x#T.aOV#T#e.hXV#T``OX({Z]({^p({qr({sw({x!P({!Q!^({!a$f({$g~({#e/Ya``OX0_XZ1iZ]0_]^1i^p0_qr0_rs1isw0_wx1ix!P0_!P!Q1i!Q!]0_!]!^({!^!a1i!a$f0_$f$g1i$g~0_#e0da``OX0_XZ1iZ]0_]^1i^p0_qr0_rs1isw0_wx1ix!P0_!P!Q1i!Q!]0_!]!^1}!^!a1i!a$f0_$f$g1i$g~0_#T1lSOp1iq!]1i!]!^1x!^~1i#T1}OW#T#e2UXW#T``OX({Z]({^p({qr({sw({x!P({!Q!^({!a$f({$g~({#g2zU{!tUPzpOr'lrs'Rsv'lw!^'l!^!_(V!_~'l#Z3gXUPzp|!bOr%{rs&ksv%{wx'lx!^%{!^!_(e!_!`%{!`!a4S!a~%{#Z4_VaUUPzp|!bOr%{rs&ksv%{wx'lx!^%{!^!_(e!_~%{#s5V!Y]ScWZQUP``zp|!bOX$eXZ%{Z]$e]^%{^p$epq%{qr$ers&ksv$evw({wx'lx}$e}!O4t!O!P4t!P!Q%{!Q![4t![!]4t!]!^$e!^!_(e!_!a%{!a!c$e!c!}4t!}#R$e#R#S4t#S#T$e#T#o4t#o$f$e$f$g%{$g$}$e$}%O4t%O%W$e%W%o4t%o%p$e%p&a4t&a&b$e&b1p4t1p4U4t4U4d4t4d4e$e4e$IS4t$IS$I`$e$I`$Ib4t$Ib$Je$e$Je$Jg4t$Jg$Kh$e$Kh%#t4t%#t&/x$e&/x&Et4t&Et&FV$e&FV;'S4t;'S;:j8u;:j?&r$e?&r?Ah4t?Ah?BY$e?BY?Mn4t?Mn~$e#s9QeUP``zp|!bOX$eXZ%{Z]$e]^%{^p$epq%{qr$ers&ksv$evw({wx'lx!P$e!P!Q%{!Q!^$e!^!_(e!_!a%{!a$f$e$f$g%{$g;=`$e;=`<%l4t<%l~$e#T:jWzp|!bOq(eqr;Srs'asv(ewx(Vx!a(e!a!bNn!b~(e#T;ZZzp|!bOr(ers'asv(ewx(Vx}(e}!O;|!O!f(e!f!gDV!g#W(e#W#XKO#X~(e#T<TVzp|!bOr(ers'asv(ewx(Vx}(e}!O<j!O~(e#T<qWzp|!bOr<jrs=Zsv<jvw=owx?}x}<j}!OBV!O~<j!c=`T|!bOv=Zvx=ox}=Z}!O>p!O~=ZP=rRO}=o}!O={!O~=oP>ORO}=o}!O>X!O~=oP>[TO}=o}!O>X!O!`=o!`!a>k!a~=oP>pOeP!c>uT|!bOv=Zvx=ox}=Z}!O?U!O~=Z!c?ZV|!bOv=Zvx=ox}=Z}!O?U!O!`=Z!`!a?p!a~=Z!c?wQ|!bePOv'ax~'aq@SVzpOr?}rs=osv?}vw=ow}?}}!O@i!O~?}q@nVzpOr?}rs=osv?}vw=ow}?}}!OAT!O~?}qAYXzpOr?}rs=osv?}vw=ow}?}}!OAT!O!`?}!`!aAu!a~?}qA|RzpePOr(Vsv(Vw~(V#TB^Wzp|!bOr<jrs=Zsv<jvw=owx?}x}<j}!OBv!O~<j#TB}Yzp|!bOr<jrs=Zsv<jvw=owx?}x}<j}!OBv!O!`<j!`!aCm!a~<j#TCvTzp|!bePOr(ers'asv(ewx(Vx~(e#TD^Vzp|!bOr(ers'asv(ewx(Vx!q(e!q!rDs!r~(e#TDzVzp|!bOr(ers'asv(ewx(Vx!e(e!e!fEa!f~(e#TEhVzp|!bOr(ers'asv(ewx(Vx!v(e!v!wE}!w~(e#TFUVzp|!bOr(ers'asv(ewx(Vx!{(e!{!|Fk!|~(e#TFrVzp|!bOr(ers'asv(ewx(Vx!r(e!r!sGX!s~(e#TG`Vzp|!bOr(ers'asv(ewx(Vx!g(e!g!hGu!h~(e#TG|Wzp|!bOrGursHfsvGuvwHzwxIjx!`Gu!`!aJf!a~Gu!cHkT|!bOvHfvxHzx!`Hf!`!aI]!a~HfPH}RO!`Hz!`!aIW!a~HzPI]OgP!cIdQ|!bgPOv'ax~'aqIoVzpOrIjrsHzsvIjvwHzw!`Ij!`!aJU!a~IjqJ]RzpgPOr(Vsv(Vw~(V#TJoTzp|!bgPOr(ers'asv(ewx(Vx~(e#TKVVzp|!bOr(ers'asv(ewx(Vx#c(e#c#dKl#d~(e#TKsVzp|!bOr(ers'asv(ewx(Vx#V(e#V#WLY#W~(e#TLaVzp|!bOr(ers'asv(ewx(Vx#h(e#h#iLv#i~(e#TL}Vzp|!bOr(ers'asv(ewx(Vx#m(e#m#nMd#n~(e#TMkVzp|!bOr(ers'asv(ewx(Vx#d(e#d#eNQ#e~(e#TNXVzp|!bOr(ers'asv(ewx(Vx#X(e#X#YGu#Y~(e#TNuWzp|!bOrNnrs! _svNnvw! swx!#Tx!aNn!a!b!$k!b~Nn!c! dT|!bOv! _vx! sx!a! _!a!b!!b!b~! _P! vRO!a! s!a!b!!P!b~! sP!!SRO!`! s!`!a!!]!a~! sP!!bOfP!c!!gT|!bOv! _vx! sx!`! _!`!a!!v!a~! _!c!!}Q|!bfPOv'ax~'aq!#YVzpOr!#Trs! ssv!#Tvw! sw!a!#T!a!b!#o!b~!#Tq!#tVzpOr!#Trs! ssv!#Tvw! sw!`!#T!`!a!$Z!a~!#Tq!$bRzpfPOr(Vsv(Vw~(V#T!$rWzp|!bOrNnrs! _svNnvw! swx!#Tx!`Nn!`!a!%[!a~Nn#T!%eTzp|!bfPOr(ers'asv(ewx(Vx~(e#X!&PV^SUPzp|!bOr%{rs&ksv%{wx'lx!^%{!^!_(e!_~%{#s!&qeUP``zp|!bOX$eXZ%{Z]$e]^%{^p$epq%{qr$ers&ksv$evw({wx'lx!P$e!P!Q%{!Q!^$e!^!_(e!_!a%{!a$f$e$f$g%{$g;=`$e;=`<%l4t<%l~$e",
  tokenizers: [tagStart, selfClosed, 0, 1, 2, 3, 4, 5, 6],
  topRules: {"Document":[0,5]},
  nested: [["elementContent", elementContent,"&k~RP!^!_U~XP!P!Q[~_dXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~!pdXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~$RkXY%vYZ%v]^%vpq%v}!O$O!O!P$O!Q![$O![!]$O!`!a&Y!c!}$O#R#S$O#T#o$O$}%O$O%W%o$O%p&a$O&b1p$O1p4U$O4U4d$O4e$IS$O$I`$Ib$O$Je$Jg$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&_?&r?Ah$O?BY?Mn$O~%yTXY%vYZ%v]^%vpq%v!`!a&Y~&_Ou~~&bP;=`<%l$O~&hP;=`<%l$O", 45]],
  specializeTable: 0,
  tokenPrec: 349
});

function configureHTML(tags) { return configureTags(parser, tags) }

exports.configureHTML = configureHTML;
exports.parser = parser;
